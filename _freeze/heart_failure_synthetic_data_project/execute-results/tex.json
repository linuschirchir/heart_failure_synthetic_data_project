{
  "hash": "48d69bd3162fc2ec315b96371760ce03",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: |\n  ::: {.centered}\n  Heart Failure Clinical Records Synthetic Data Project\n  :::\nauthor: Linus Chirchir\ndate: 7 September 2025\ndate-format: \"D MMMM YYYY\"\npage-layout: full\nformat: \n  html:\n    toc: true\n    toc-depth: 4\n    toc-location: left\n    toc-float: true\n    number-sections: true\n    toc-title: \"Contents\"\n    css: styles/styles.css\n    code-fold: true\n    code-summary: \"Show code\"\n    code-tools: true\n    code-overflow: wrap\n  docx:\n    toc: true\n    toc-depth: 5\n    toc-location: left\n    toc-float: true\n    number-sections: true\n    toc-title: \"Contents\"\n    css: styles.css    \n  pdf:\n    engine: xelatex\n    toc: true\n    toc-depth: 4\n    number-sections: true\n    colorlinks: true\n    lof: false\n    lot: true\n    keep-tex: true\nexecute:\n  warning: false\n  message: false\nfreeze: auto\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load necessary libraries\n# --- Project and Performance Utilities ---\nlibrary(here)                 # Manage project-relative file paths\nlibrary(doParallel)           # Enable parallel processing for faster computations\nlibrary(tidyverse)            # Core data science toolkit (dplyr, tidyr, readr, purrr, etc.)\nlibrary(readxl)               # Import Excel (.xlsx, .xls) files into R\n\n# --- Data Exploration and Summaries ---\nlibrary(DataExplorer)         # Automate exploratory data analysis (EDA) and visual summaries\nlibrary(skimr)                # Generate concise data summaries with skim()\nlibrary(psych)                # Produce descriptive statistics and psychometric analyses\nlibrary(knitr)                # Format dynamic tables and reports in Markdown/Quarto\n\n# --- Visualisation ---\nlibrary(ggplot2)              # Build customizable, high-quality data visualizations\nlibrary(patchwork)            # Combine multiple ggplot2 plots into unified layouts\nlibrary(corrplot)             # Visualize correlation matrices with heatmaps and plots\nlibrary(GGally)               # Extend ggplot2 with correlation plots, pairwise plots, ggpairs()\nlibrary(PerformanceAnalytics) # Create financial-style charts (correlations, histograms, scatterplots)\nlibrary(VIM)                  # Visualize/impute missing values with advanced methods (e.g., matrix plots)\nlibrary(scales)\n\n# --- Data Imputation and Synthesis ---\nlibrary(mice)                 # Perform multiple imputation by chained equations for missing data\nlibrary(synthpop)             # Generate, evaluate, and compare synthetic datasets\n\n# --- Statistical and Information-Theoretic Measures ---\nlibrary(transport)            # Compute optimal transport distances (e.g., Wasserstein) for distribution comparison\nlibrary(infotheo)             # Calculate information-theoretic metrics (entropy, mutual information)\n\n# --- Modeling and Machine Learning ---\nlibrary(caret)                # Streamline machine learning workflows (training, tuning, evaluation)\nlibrary(xgboost)              # Implement gradient boosting for classification/regression\nlibrary(SHAPforxgboost)       # Explain XGBoost predictions using SHAP values\nlibrary(FNN)                  # Perform fast k-nearest neighbor searches and distance calculations\n\n# Set up parallel processing\nnum_cores <- detectCores() - 1  # Use one less than the total number of cores\ncl <- makeCluster(num_cores)\nregisterDoParallel(cl)\n```\n:::\n\n\n\n\n\n\\newpage\n\n## Introduction\n\nThis project evaluates the quality of synthetic datasets derived from the Heart Failure Clinical Records data (299 patients, 13 variables). Our goal is to determine how well different generation strategies reproduce the statistical properties and analytic value of the original data while protecting privacy.\nWe generate synthetic data using four approaches: (1) parametric imputation (MICE), (2) non-parametric imputation (CART via MICE), (3) distribution-driven synthesis (synthpop), and (4) metadata-guided rules. We then compare each synthetic dataset with the real data across three dimensions:\n\n-\tFidelity – univariate and multivariate similarity (distributions, ranges, correlations), histogram similarity, and mutual information.\n-\tUtility – model transportability using XGBoost (TRTR vs. TSTR), feature-importance agreement, and SHAP-based behaviour.\n-\tPrivacy / Disclosure risk – exact record matches, neighbour-proximity checks, and membership-inference sensitivity.\n\nResults are presented through aligned tables and plots (structure checks, categorical level retention, density overlays, correlation matrices, SHAP summaries) with concise scores for each method. The report concludes with a comparative summary to guide method selection given different fidelity–utility–privacy trade-offs.\n\n## Heart Failure Clinical Records Dataset and Initial Exploration  \n\nThe **Heart Failure Clinical Records dataset**, sourced from the [UCI Machine Learning Repository](https://archive.ics.uci.edu/dataset/519/heart+failure+clinical+records), contains records of **299 patients** with heart failure collected during their follow-up period. Each record includes **13 clinical features** covering demographics, clinical conditions, and laboratory measures:  \n\n| Variable                    | Description                                          | Unit / Levels        |\n|-----------------------------|------------------------------------------------------|----------------------|\n| **age**                     | Age of the patient                                   | Years                |\n| **anaemia**                 | Reduction in red blood cells                         | No / Yes             |\n| **creatinine_phosphokinase**| Enzyme level in the blood                            | mcg/L                |\n| **diabetes**                | Diabetes status                                      | No / Yes             |\n| **ejection_fraction**       | % of blood leaving the heart with each contraction   | Percentage (%)       |\n| **platelets**               | Platelet count                                       | Kiloplatelets/mL     |\n| **serum_creatinine**        | Serum creatinine level                               | mg/dL                |\n| **serum_sodium**            | Serum sodium level                                   | mEq/L                |\n| **sex**                     | Gender of the patient                                | Female / Male        |\n| **smoking**                 | Smoking status                                       | No / Yes             |\n| **hypertension**            | Hypertension status                                  | No / Yes             |\n| **deceased**                | Survival status during follow-up                     | No / Yes             |\n| **follow_up**               | Duration of the follow-up period                     | Days                 |\n\n<br>\n\nA preview of the first 10 rows of the dataset is shown below.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set seed for reproducibility\nset.seed(123)\n\n# Load the heart failure dataset from the local directory\nheart_failure <- read.csv(here(\"data\", \"heart_failure.csv\"))\n\n# Let's preview the heart failure dataset\nknitr::kable(\n  head(heart_failure, 10),\n  caption = \"Preview of the first 10 rows of the Heart Failure dataset\",\n  align = rep(\"l\", ncol(heart_failure))  # left align all columns\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Preview of the first 10 rows of the Heart Failure dataset\n\n|age |anaemia |creatinine_phosphokinase |diabetes |ejection_fraction |platelets |serum_creatinine |serum_sodium |sex    |smoking |hypertension |deceased |follow_up |\n|:---|:-------|:------------------------|:--------|:-----------------|:---------|:----------------|:------------|:------|:-------|:------------|:--------|:---------|\n|75  |No      |582                      |No       |20                |265000    |1.9              |130          |Male   |No      |Yes          |Yes      |4         |\n|55  |No      |7861                     |No       |NA                |263358    |1.1              |NA           |Male   |No      |No           |Yes      |6         |\n|65  |No      |NA                       |No       |20                |162000    |NA               |129          |Male   |Yes     |No           |Yes      |7         |\n|NA  |Yes     |111                      |No       |NA                |NA        |1.9              |NA           |Male   |No      |No           |Yes      |7         |\n|65  |Yes     |160                      |Yes      |20                |327000    |2.7              |116          |Female |No      |No           |Yes      |8         |\n|90  |Yes     |47                       |No       |40                |204000    |NA               |132          |Male   |Yes     |Yes          |Yes      |8         |\n|75  |Yes     |246                      |No       |15                |NA        |1.2              |NA           |Male   |No      |No           |Yes      |10        |\n|60  |Yes     |315                      |Yes      |60                |454000    |1.1              |131          |Male   |Yes     |No           |Yes      |10        |\n|NA  |No      |NA                       |No       |65                |263358    |NA               |NA           |Female |No      |No           |Yes      |10        |\n|80  |Yes     |123                      |No       |35                |388000    |9.4              |133          |Male   |Yes     |Yes          |Yes      |10        |\n\n\n:::\n:::\n\n\n\n\n\n<br>\n\nHere's the preview of the structure of the heart failure dataset.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display the structure of the dataset\ndata.frame(\n  Variable = names(heart_failure),\n  Type = sapply(heart_failure, \\(x) paste(class(x), collapse = \", \")),\n  Values = sapply(heart_failure, \\(x) paste(head(unique(x), 10), collapse = \", \"))\n) |>\n  knitr::kable(\n    caption = \"Structure of the Heart Failure Dataset: Variables, Types, and Values\",\n    align = c(\"l\",\"l\",\"l\")\n  )\n```\n\n::: {.cell-output-display}\n\n\nTable: Structure of the Heart Failure Dataset: Variables, Types, and Values\n\n|                         |Variable                 |Type      |Values                                                                        |\n|:------------------------|:------------------------|:---------|:-----------------------------------------------------------------------------|\n|age                      |age                      |numeric   |75, 55, 65, NA, 90, 60, 80, 62, 45, 50                                        |\n|anaemia                  |anaemia                  |character |No, Yes                                                                       |\n|creatinine_phosphokinase |creatinine_phosphokinase |integer   |582, 7861, NA, 111, 160, 47, 246, 315, 123, 81                                |\n|diabetes                 |diabetes                 |character |No, Yes                                                                       |\n|ejection_fraction        |ejection_fraction        |integer   |20, NA, 40, 15, 60, 65, 35, 38, 25, 30                                        |\n|platelets                |platelets                |numeric   |265000, 263358.03, 162000, NA, 327000, 204000, 454000, 388000, 368000, 253000 |\n|serum_creatinine         |serum_creatinine         |numeric   |1.9, 1.1, NA, 2.7, 1.2, 9.4, 4, 0.9, 1, 1.3                                   |\n|serum_sodium             |serum_sodium             |integer   |130, NA, 129, 116, 132, 131, 133, 140, 137, 138                               |\n|sex                      |sex                      |character |Male, Female                                                                  |\n|smoking                  |smoking                  |character |No, Yes                                                                       |\n|hypertension             |hypertension             |character |Yes, No                                                                       |\n|deceased                 |deceased                 |character |Yes, No                                                                       |\n|follow_up                |follow_up                |integer   |4, 6, 7, 8, 10, 11, 12, 13, 14, 15                                            |\n\n\n:::\n:::\n\n\n\n\n\n<br>\n\nLet's perform some basic data cleaning and preprocessing steps. Convert the following columns to factors: sex, anaemia, diabetes, smoking, hypertension and deceased. Here's the new structure of the dataset after the basic cleaning.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert the specified columns to factors\nheart_failure$sex <- as.factor(heart_failure$sex)\nheart_failure$anaemia <- as.factor(heart_failure$anaemia)\nheart_failure$diabetes <- as.factor(heart_failure$diabetes)\nheart_failure$smoking <- as.factor(heart_failure$smoking)\nheart_failure$hypertension <- as.factor(heart_failure$hypertension)\nheart_failure$deceased <- as.factor(heart_failure$deceased)\n```\n:::\n\n\n\n\n\nHere are the summary statistics of the heart failure dataset.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate descriptive statistics and display as a single table\ndescribe(heart_failure) |>\n  kable(\n    caption = \"Summary Statistics of the Heart Failure Dataset\",\n    digits = 2,  # round to 2 decimal places\n    align = \"lrrrrrrrrrr\"  # left for variable, right for numbers\n  )\n```\n\n::: {.cell-output-display}\n\n\nTable: Summary Statistics of the Heart Failure Dataset\n\n|                         |vars |   n|      mean|       sd|   median|   trimmed|      mad|     min|      max|    range|  skew|kurtosis |      se|\n|:------------------------|:----|---:|---------:|--------:|--------:|---------:|--------:|-------:|--------:|--------:|-----:|:--------|-------:|\n|age                      |1    | 284|     60.80|    12.08|     60.0|     60.15|    14.83|    40.0|     95.0|     55.0|  0.42|-0.28    |    0.72|\n|anaemia*                 |2    | 299|      1.43|     0.50|      1.0|      1.41|     0.00|     1.0|      2.0|      1.0|  0.28|-1.93    |    0.03|\n|creatinine_phosphokinase |3    | 285|    578.81|   981.99|    249.0|    358.95|   268.35|    23.0|   7861.0|   7838.0|  4.45|24.52    |   58.17|\n|diabetes*                |4    | 299|      1.42|     0.49|      1.0|      1.40|     0.00|     1.0|      2.0|      1.0|  0.33|-1.90    |    0.03|\n|ejection_fraction        |5    | 287|     38.00|    11.92|     38.0|     37.31|    11.86|    14.0|     80.0|     66.0|  0.58|0.02     |    0.70|\n|platelets                |6    | 285| 265163.83| 97508.63| 263358.0| 259212.20| 65765.22| 25100.0| 850000.0| 824900.0|  1.43|6.24     | 5775.91|\n|serum_creatinine         |7    | 281|      1.39|     1.05|      1.1|      1.18|     0.30|     0.5|      9.4|      8.9|  4.44|25.03    |    0.06|\n|serum_sodium             |8    | 279|    136.59|     4.49|    137.0|    136.80|     4.45|   113.0|    148.0|     35.0| -1.05|3.88     |    0.27|\n|sex*                     |9    | 299|      1.65|     0.48|      2.0|      1.68|     0.00|     1.0|      2.0|      1.0| -0.62|-1.62    |    0.03|\n|smoking*                 |10   | 299|      1.32|     0.47|      1.0|      1.28|     0.00|     1.0|      2.0|      1.0|  0.76|-1.42    |    0.03|\n|hypertension*            |11   | 299|      1.35|     0.48|      1.0|      1.32|     0.00|     1.0|      2.0|      1.0|  0.62|-1.62    |    0.03|\n|deceased*                |12   | 299|      1.32|     0.47|      1.0|      1.28|     0.00|     1.0|      2.0|      1.0|  0.76|-1.42    |    0.03|\n|follow_up                |13   | 299|    130.26|    77.61|    115.0|    129.28|   105.26|     4.0|    285.0|    281.0|  0.13|-1.22    |    4.49|\n\n\n:::\n:::\n\n\n\n\n\n## Generating Synthetic Data\n\nThe process of generating synthetic data is essential for tasks such as privacy preservation, testing machine learning models, and conducting simulations. In this section, we employ various techniques to generate synthetic data based on the real heart failure dataset. Each method serves a different purpose and offers distinct advantages, depending on the use case and the type of missing data or privacy concerns.\n\nWe explore four key approaches for generating synthetic data:\n\n### Parametric Imputation Using MICE\n\nThis method uses the Multivariate Imputation by Chained Equations (MICE) framework, with parametric imputation based on a normal distribution. MICE allows for handling missing data through multiple imputations and is widely used in data science and healthcare for its flexibility and statistical rigor. Here's the preview of the first 10 rows of the synthetic data generated.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to compute the 5th and 95th percentiles for numeric columns\ncompute_percentiles <- function(data, lower_percentile = 0.05, upper_percentile = 0.95) {\n  percentiles <- lapply(data, function(column) {\n    if (is.numeric(column)) {\n      lower <- quantile(column, probs = lower_percentile, na.rm = TRUE)\n      upper <- quantile(column, probs = upper_percentile, na.rm = TRUE)\n      return(c(lower, upper))\n    }\n    return(c(NA, NA))\n  })\n  names(percentiles) <- names(data)\n  return(percentiles)\n}\n\n# Function to scale numeric values based on the 5th and 95th percentiles\nscale_to_percentiles <- function(data, percentiles) {\n  scaled_data <- data\n  for (col in colnames(data)) {\n    if (is.numeric(data[[col]])) {\n      # Apply scaling only if percentiles are available for this column\n      if (!is.na(percentiles[[col]][1]) && !is.na(percentiles[[col]][2])) {\n        min_val <- percentiles[[col]][1]\n        max_val <- percentiles[[col]][2]\n        # Clip values to lie within the 5th and 95th percentile range\n        scaled_data[[col]] <- pmin(pmax(data[[col]], min_val), max_val)\n      }\n    }\n  }\n  return(scaled_data)\n}\n\n# Function to generate missingness in a dataset based on the real data's pattern\ngenerate_missingness_based_on_real <- function(real_data, synthetic_data) {\n  # Ensure the synthetic dataset has the same structure as the real\n  if (!all(colnames(real_data) == colnames(synthetic_data))) {\n    stop(\"Column names in real and synthetic data must match\")\n  }\n  \n  # Copy the real missingness pattern to the synthetic dataset\n  synthetic_data_with_missingness <- synthetic_data\n  for (col in colnames(real_data)) {\n    # Apply missingness where it was present in the real data\n    missing_indices <- is.na(real_data[[col]])\n    synthetic_data_with_missingness[[col]][missing_indices] <- NA\n  }\n  \n  return(synthetic_data_with_missingness)\n}\n\n# Compute the 5th and 95th percentiles for the real data\npercentiles <- compute_percentiles(heart_failure)\n\n# Generate synthetic data using MICE\nwhere <- make.where(heart_failure, \"all\")\nmethod <- make.method(heart_failure, where = where)\nmethod[method == \"pmm\"] <- \"norm\"\n\n# Perform multiple imputation (10 datasets)\nsyn_param <- mice(heart_failure, m = 10, maxit = 1, method = method, where = where, printFlag = FALSE)\n\n# Extract the first synthetic dataset\nsyn_data_1 <- complete(syn_param, 1)\n\n# Scale synthetic data to the 5th and 95th percentile ranges\nsyn_data_1 <- scale_to_percentiles(syn_data_1, percentiles)\n\n# Apply the real missingness pattern to the synthetic dataset\nsyn_data_1 <- generate_missingness_based_on_real(heart_failure, syn_data_1)\n\n# Round off all numeric columns to 0 decimal places\nsyn_data_1 <- syn_data_1 %>%\n  mutate(across(where(is.numeric), round, digits = 0))\n\n# Add a prefix 'synth_' to all synthetic dataset variable names\ncolnames(syn_data_1) <- paste(\"synth\", colnames(syn_data_1), sep = \"_\")\n\n# Display the structure of the dataset\ndata.frame(\n  Variable = names(syn_data_1),\n  Type = sapply(syn_data_1, \\(x) paste(class(x), collapse = \", \")),\n  Values = sapply(syn_data_1, \\(x) paste(head(unique(x), 10), collapse = \", \"))\n) |>\n  knitr::kable(\n    caption = \"Structure of the Heart Failure Dataset: Variables, Types, and Values\",\n    align = c(\"l\",\"l\",\"l\")\n  )\n```\n\n::: {.cell-output-display}\n\n\nTable: Structure of the Heart Failure Dataset: Variables, Types, and Values\n\n|                               |Variable                       |Type    |Values                                                                     |\n|:------------------------------|:------------------------------|:-------|:--------------------------------------------------------------------------|\n|synth_age                      |synth_age                      |numeric |56, 42, 57, NA, 69, 53, 72, 59, 82, 73                                     |\n|synth_anaemia                  |synth_anaemia                  |factor  |No, Yes                                                                    |\n|synth_creatinine_phosphokinase |synth_creatinine_phosphokinase |numeric |184, 1540, NA, 559, 941, 1926, 570, 1380, 59, 1531                         |\n|synth_diabetes                 |synth_diabetes                 |factor  |No, Yes                                                                    |\n|synth_ejection_fraction        |synth_ejection_fraction        |numeric |40, NA, 52, 48, 49, 27, 33, 51, 30, 39                                     |\n|synth_platelets                |synth_platelets                |numeric |284572, 235177, 175379, NA, 352540, 132200, 349886, 421200, 246142, 265262 |\n|synth_serum_creatinine         |synth_serum_creatinine         |numeric |2, 1, NA, 3                                                                |\n|synth_serum_sodium             |synth_serum_sodium             |numeric |138, NA, 131, 130, 137, 135, 142, 134, 141, 144                            |\n|synth_sex                      |synth_sex                      |factor  |Male, Female                                                               |\n|synth_smoking                  |synth_smoking                  |factor  |Yes, No                                                                    |\n|synth_hypertension             |synth_hypertension             |factor  |Yes, No                                                                    |\n|synth_deceased                 |synth_deceased                 |factor  |Yes, No                                                                    |\n|synth_follow_up                |synth_follow_up                |numeric |90, 13, 88, 40, 31, 129, 91, 51, 29, 118                                   |\n\n\n:::\n:::\n\n\n\n\n\n### Non-Parametric Imputation Using CART\n\nThe Classification and Regression Trees (CART) method, a non-parametric approach, is useful for imputation when the relationships between variables are complex or non-linear. By leveraging decision trees, CART is capable of capturing intricate patterns in the data without making strong assumptions about the underlying distributions. Here's the preview of the first 10 rows of the synthetic data generated.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute the 5th and 95th percentiles for the real data\npercentiles <- compute_percentiles(heart_failure)\n\n# Generate synthetic data using CART imputation with MICE\nwhere <- make.where(heart_failure, \"all\")\nmethod <- make.method(heart_failure, where = where)\nmethod[method == \"pmm\"] <- \"cart\"  # Set the method to \"cart\" for non-parametric imputation\n\n# Perform multiple imputation (10 datasets)\nsyn_cart <- mice(heart_failure, m = 10, maxit = 1, method = method, where = where, printFlag = FALSE)\n\n# Extract the first synthetic dataset\nsyn_cart_1 <- complete(syn_cart, 1)\n\n# Scale synthetic data to the 5th and 95th percentile ranges\nsyn_cart_1 <- scale_to_percentiles(syn_cart_1, percentiles)\n\n# Apply the real missingness pattern to the synthetic dataset\nsyn_cart_1 <- generate_missingness_based_on_real(heart_failure, syn_cart_1)\n\n# Round off all numeric columns to 0 decimal places\nsyn_cart_1 <- syn_cart_1 %>%\n  mutate(across(where(is.numeric), round, digits = 0))\n\n# Add a prefix 'synth_' to all synthetic dataset variable names\ncolnames(syn_cart_1) <- paste(\"synth\", colnames(syn_cart_1), sep = \"_\")\n\n# Display the structure of the dataset\ndata.frame(\n  Variable = names(syn_cart_1),\n  Type = sapply(syn_cart_1, \\(x) paste(class(x), collapse = \", \")),\n  Values = sapply(syn_cart_1, \\(x) paste(head(unique(x), 10), collapse = \", \"))\n) |>\n  knitr::kable(\n    caption = \"Structure of the Heart Failure Dataset: Variables, Types, and Values\",\n    align = c(\"l\",\"l\",\"l\")\n  )\n```\n\n::: {.cell-output-display}\n\n\nTable: Structure of the Heart Failure Dataset: Variables, Types, and Values\n\n|                               |Variable                       |Type    |Values                                                                     |\n|:------------------------------|:------------------------------|:-------|:--------------------------------------------------------------------------|\n|synth_age                      |synth_age                      |numeric |60, 50, 65, NA, 82, 53, 75, 69, 70, 45                                     |\n|synth_anaemia                  |synth_anaemia                  |factor  |No, Yes                                                                    |\n|synth_creatinine_phosphokinase |synth_creatinine_phosphokinase |numeric |582, 161, NA, 203, 112, 371, 246, 60, 59, 2221                             |\n|synth_diabetes                 |synth_diabetes                 |factor  |No, Yes                                                                    |\n|synth_ejection_fraction        |synth_ejection_fraction        |numeric |30, NA, 38, 25, 50, 60, 35, 20, 45, 40                                     |\n|synth_platelets                |synth_platelets                |numeric |132200, 263358, NA, 421200, 351000, 219000, 327000, 213000, 395000, 282000 |\n|synth_serum_creatinine         |synth_serum_creatinine         |numeric |3, 1, NA, 2                                                                |\n|synth_serum_sodium             |synth_serum_sodium             |numeric |133, NA, 130, 140, 138, 139, 137, 136, 134, 135                            |\n|synth_sex                      |synth_sex                      |factor  |Female, Male                                                               |\n|synth_smoking                  |synth_smoking                  |factor  |Yes, No                                                                    |\n|synth_hypertension             |synth_hypertension             |factor  |No, Yes                                                                    |\n|synth_deceased                 |synth_deceased                 |factor  |Yes, No                                                                    |\n|synth_follow_up                |synth_follow_up                |numeric |59, 30, 154, 24, 66, 13, 28, 65, 129, 72                                   |\n\n\n:::\n:::\n\n\n\n\n\n### Generating Synthetic Data Using Synthpop\n\nThe Synthpop package is designed for creating synthetic data based on the distribution of the real dataset. It is particularly useful for privacy-preserving data sharing, where the aim is to create a synthetic dataset that mimics the real data without exposing sensitive information. Here's the preview of the first 10 rows of the synthetic data generated.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute the 5th and 95th percentiles for the real data\npercentiles <- compute_percentiles(heart_failure)\n\n# Generate low-fidelity synthetic data using random sampling\nsyn_data_low_fidelity <- syn(heart_failure, method = \"sample\", seed = 123)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nSynthesis\n-----------\n age anaemia creatinine_phosphokinase diabetes ejection_fraction platelets serum_creatinine serum_sodium sex smoking\n hypertension deceased follow_up\n```\n\n\n:::\n\n```{.r .cell-code}\n# Convert the synthetic dataset to a data frame\nsyn_data_low_fidelity_synthpop <- syn_data_low_fidelity$syn\n\n# Scale the synthetic data to the 5th and 95th percentile ranges\nsyn_data_low_fidelity_synthpop <- scale_to_percentiles(syn_data_low_fidelity_synthpop, percentiles)\n\n# Apply the real missingness pattern to the synthetic dataset\nsyn_data_low_fidelity_synthpop <- generate_missingness_based_on_real(heart_failure, syn_data_low_fidelity_synthpop)\n\n# Round off all numeric columns to 0 decimal places\nsyn_data_low_fidelity_synthpop <- syn_data_low_fidelity_synthpop %>%\n  mutate(across(where(is.numeric), round, digits = 0))\n\n# Add a prefix 'synth_' to all synthetic dataset variable names\ncolnames(syn_data_low_fidelity_synthpop) <- paste(\"synth\", colnames(syn_data_low_fidelity_synthpop), sep = \"_\")\n\n# Display the structure of the dataset\ndata.frame(\n  Variable = names(syn_data_low_fidelity_synthpop),\n  Type = sapply(syn_data_low_fidelity_synthpop, \\(x) paste(class(x), collapse = \", \")),\n  Values = sapply(syn_data_low_fidelity_synthpop, \\(x) paste(head(unique(x), 10), collapse = \", \"))\n) |>\n  knitr::kable(\n    caption = \"Structure of the Heart Failure Dataset: Variables, Types, and Values\",\n    align = c(\"l\",\"l\",\"l\")\n  )\n```\n\n::: {.cell-output-display}\n\n\nTable: Structure of the Heart Failure Dataset: Variables, Types, and Values\n\n|                               |Variable                       |Type    |Values                                                                     |\n|:------------------------------|:------------------------------|:-------|:--------------------------------------------------------------------------|\n|synth_age                      |synth_age                      |numeric |63, 50, 45, NA, 73, 57, 70, 52, 65, 80                                     |\n|synth_anaemia                  |synth_anaemia                  |factor  |Yes, No                                                                    |\n|synth_creatinine_phosphokinase |synth_creatinine_phosphokinase |numeric |427, 335, NA, 249, 64, 1610, 2221, 224, 910, 260                           |\n|synth_diabetes                 |synth_diabetes                 |factor  |No, Yes                                                                    |\n|synth_ejection_fraction        |synth_ejection_fraction        |numeric |25, NA, 20, 40, 60, 30, 35, 38, 45, 50                                     |\n|synth_platelets                |synth_platelets                |numeric |NA, 229000, 385000, 277000, 268000, 271000, 274000, 189000, 236000, 329000 |\n|synth_serum_creatinine         |synth_serum_creatinine         |numeric |1, NA, 2, 3                                                                |\n|synth_serum_sodium             |synth_serum_sodium             |numeric |142, NA, 139, 136, 137, 134, 140, 130, 144, 135                            |\n|synth_sex                      |synth_sex                      |factor  |Male, Female                                                               |\n|synth_smoking                  |synth_smoking                  |factor  |Yes, No                                                                    |\n|synth_hypertension             |synth_hypertension             |factor  |Yes, No                                                                    |\n|synth_deceased                 |synth_deceased                 |factor  |Yes, No                                                                    |\n|synth_follow_up                |synth_follow_up                |numeric |250, 13, 91, 121, 20, 113, 186, 85, 74, 50                                 |\n\n\n:::\n:::\n\n\n\n\n\n### Generating Synthetic Data Using Metadada\n\nThis method uses a data dictionary (metadata) to drive the generation of synthetic data. The metadata defines the structure and types of variables, which ensures that the generated synthetic data conforms to expected formats, such as ranges for continuous variables and categories for binary or categorical variables. Here's the preview of the first 10 rows of the synthetic data generated.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute the 5th and 95th percentiles for the real data\npercentiles <- compute_percentiles(heart_failure)\n\n# Generate synthetic data using metadata\n\n# Load the metadata from the Excel file\nheart_failure_metadata <- read_excel(here(\"data\", \"heart_failure_metadata.xlsx\"))\n\n# Create an empty data frame based on the metadata structure\nn_rows <- nrow(heart_failure)  # Number of synthetic records to generate\nvariable_names <- heart_failure_metadata$`Variable Name`\ndata_types <- heart_failure_metadata$Type\n\nsyn_data_metadata <- data.frame(matrix(ncol = length(variable_names), nrow = n_rows))\ncolnames(syn_data_metadata) <- variable_names\n\n# Function to generate data based on metadata\ngenerate_data <- function(variable, real_data, type, n) {\n  if (type == \"Continuous\" || type == \"Integer\") {\n    if (is.numeric(real_data[[variable]])) {\n      # Compute 5th and 95th percentiles for numeric variables\n      p5 <- quantile(real_data[[variable]], probs = 0.05, na.rm = TRUE)\n      p95 <- quantile(real_data[[variable]], probs = 0.95, na.rm = TRUE)\n      \n      if (type == \"Continuous\") {\n        return(runif(n, min = p5, max = p95))\n      } else if (type == \"Integer\") {\n        return(sample(floor(p5):ceiling(p95), n, replace = TRUE))\n      }\n    }\n  } else if (is.factor(real_data[[variable]])) {\n    return(sample(levels(real_data[[variable]]), n, replace = TRUE))\n  } else if (variable %in% c(\"anaemia\", \"diabetes\", \"hypertension\", \"smoking\", \"sex\")) {\n    return(sample(unique(real_data[[variable]]), n, replace = TRUE))\n  } else {\n    return(rep(NA, n))\n  }\n}\n\n# Generate synthetic data based on the metadata\nfor (i in seq_along(variable_names)) {\n  syn_data_metadata[[i]] <- generate_data(variable_names[i], heart_failure, data_types[i], n_rows)\n}\n\n# Scale the synthetic data to the 5th and 95th percentile ranges\nsyn_data_metadata <- scale_to_percentiles(syn_data_metadata, percentiles)\n\n# Apply the real missingness pattern to the synthetic dataset\nsyn_data_metadata <- generate_missingness_based_on_real(heart_failure, syn_data_metadata)\n\n# Round off all numeric columns to 0 decimal places\nsyn_data_metadata <- syn_data_metadata %>%\n  mutate(across(where(is.numeric), round, digits = 0))\n\n# Add a prefix 'synth_' to all synthetic dataset variable names\ncolnames(syn_data_metadata) <- paste(\"synth\", colnames(syn_data_metadata), sep = \"_\")\n\n# Display the structure of the dataset\ndata.frame(\n  Variable = names(syn_data_metadata),\n  Type = sapply(syn_data_metadata, \\(x) paste(class(x), collapse = \", \")),\n  Values = sapply(syn_data_metadata, \\(x) paste(head(unique(x), 10), collapse = \", \"))\n) |>\n  knitr::kable(\n    caption = \"Structure of the Heart Failure Dataset: Variables, Types, and Values\",\n    align = c(\"l\",\"l\",\"l\")\n  )\n```\n\n::: {.cell-output-display}\n\n\nTable: Structure of the Heart Failure Dataset: Variables, Types, and Values\n\n|                               |Variable                       |Type      |Values                                                                     |\n|:------------------------------|:------------------------------|:---------|:--------------------------------------------------------------------------|\n|synth_age                      |synth_age                      |numeric   |45, 51, 82, NA, 80, 66, 59, 71, 47, 57                                     |\n|synth_anaemia                  |synth_anaemia                  |character |Yes, No                                                                    |\n|synth_creatinine_phosphokinase |synth_creatinine_phosphokinase |numeric   |180, 1663, NA, 191, 571, 1228, 395, 1553, 812, 335                         |\n|synth_diabetes                 |synth_diabetes                 |character |Yes, No                                                                    |\n|synth_ejection_fraction        |synth_ejection_fraction        |numeric   |31, NA, 58, 60, 29, 26, 37, 33, 24, 28                                     |\n|synth_platelets                |synth_platelets                |numeric   |210137, 203132, 257570, NA, 395609, 331643, 171789, 279683, 413390, 185403 |\n|synth_serum_creatinine         |synth_serum_creatinine         |numeric   |3, 1, NA, 2                                                                |\n|synth_serum_sodium             |synth_serum_sodium             |numeric   |136, NA, 138, 131, 130, 135, 134, 137, 143, 142                            |\n|synth_sex                      |synth_sex                      |character |Female, Male                                                               |\n|synth_smoking                  |synth_smoking                  |character |Yes, No                                                                    |\n|synth_hypertension             |synth_hypertension             |character |Yes, No                                                                    |\n|synth_deceased                 |synth_deceased                 |character |No, Yes                                                                    |\n|synth_follow_up                |synth_follow_up                |numeric   |152, 231, 199, 46, 188, 117, 57, 248, 90, 237                              |\n\n\n:::\n:::\n\n\n\n\n\n## Synthetic Data Identification\n\nIn this section, we generate tables to identify which columns in the synthetic datasets are synthetic (prefixed with \"synth_\") and which remain unchanged from the real dataset. This helps ensure clarity on which variables have been altered during the synthetic data generation process.\n\nFor each dataset, we produce a table displaying the column names and whether the column is synthetic. A column is marked \"Yes\" if it was generated synthetically and \"No\" if it was retained from the real data.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to create column info with dataset name\ncreate_column_info <- function(dataset, dataset_name) {\n  data.frame(\n    column_name = colnames(dataset),\n    dataset = dataset_name,\n    is_synthetic = ifelse(grepl(\"^synth_\", colnames(dataset)), \"Yes\", \"No\"),\n    stringsAsFactors = FALSE\n  )\n}\n\n# Collect column info for all datasets\nall_column_info <- bind_rows(\n  create_column_info(syn_data_1, \"Parametric MICE\"),\n  create_column_info(syn_cart_1, \"CART Imputation\"),\n  create_column_info(syn_data_low_fidelity_synthpop, \"Synthpop (Low Fidelity)\"),\n  create_column_info(syn_data_metadata, \"Metadata-Based\")\n)\n\n# Reshape into wide format so variables appear once\nwide_column_info <- all_column_info %>%\n  pivot_wider(\n    names_from = dataset,\n    values_from = is_synthetic\n  )\n\n# Display the combined wide table\nkable(\n  wide_column_info,\n  caption = \"Synthetic Indicators for Each Variable Across Datasets\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Synthetic Indicators for Each Variable Across Datasets\n\n|column_name                    |Parametric MICE |CART Imputation |Synthpop (Low Fidelity) |Metadata-Based |\n|:------------------------------|:---------------|:---------------|:-----------------------|:--------------|\n|synth_age                      |Yes             |Yes             |Yes                     |Yes            |\n|synth_anaemia                  |Yes             |Yes             |Yes                     |Yes            |\n|synth_creatinine_phosphokinase |Yes             |Yes             |Yes                     |Yes            |\n|synth_diabetes                 |Yes             |Yes             |Yes                     |Yes            |\n|synth_ejection_fraction        |Yes             |Yes             |Yes                     |Yes            |\n|synth_platelets                |Yes             |Yes             |Yes                     |Yes            |\n|synth_serum_creatinine         |Yes             |Yes             |Yes                     |Yes            |\n|synth_serum_sodium             |Yes             |Yes             |Yes                     |Yes            |\n|synth_sex                      |Yes             |Yes             |Yes                     |Yes            |\n|synth_smoking                  |Yes             |Yes             |Yes                     |Yes            |\n|synth_hypertension             |Yes             |Yes             |Yes                     |Yes            |\n|synth_deceased                 |Yes             |Yes             |Yes                     |Yes            |\n|synth_follow_up                |Yes             |Yes             |Yes                     |Yes            |\n\n\n:::\n:::\n\n\n\n\n\n## Synthetic Dataset Structure\n\n### Dataset Size and Structure Comparison\n\nThis step evaluates whether the synthetic datasets match the real dataset in terms of the number of rows, columns, and feature types. Consistency in these dimensions is essential for the synthetic data to be a reliable stand-in for the real.\n\n- **Number of Rows**: Indicates if the synthetic data captures the same number of records as the real. Any mismatch can impact comparability.\n  \n- **Number of Columns**: Ensures all variables are retained. Missing or extra columns suggest structural issues.\n\n- **Feature Types**: Confirms that categorical, numerical, and other variable types remain unchanged, preserving analytical consistency.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to extract structure info\nget_structure_info <- function(real_data, synthetic_data, dataset_name) {\n  tibble(\n    Dataset = dataset_name,\n    Rows_Real = nrow(real_data),\n    Cols_Real = ncol(real_data),\n    Rows_Synthetic = nrow(synthetic_data),\n    Cols_Synthetic = ncol(synthetic_data),\n    Structure_Match = ifelse(\n      nrow(real_data) == nrow(synthetic_data) & ncol(real_data) == ncol(synthetic_data),\n      \"✅ Yes\", \"❌ No\"\n    )\n  )\n}\n\n# Collect results\nstructure_comparison <- bind_rows(\n  get_structure_info(heart_failure, syn_data_1, \"Parametric MICE\"),\n  get_structure_info(heart_failure, syn_cart_1, \"CART Imputation\"),\n  get_structure_info(heart_failure, syn_data_low_fidelity_synthpop, \"Synthpop (Low Fidelity)\"),\n  get_structure_info(heart_failure, syn_data_metadata, \"Metadata-Based\")\n)\n\n# Display as a neat table\nkable(\n  structure_comparison,\n  caption = \"Comparison of Real vs Synthetic Dataset Sizes and Structures\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Comparison of Real vs Synthetic Dataset Sizes and Structures\n\n|Dataset                 | Rows_Real| Cols_Real| Rows_Synthetic| Cols_Synthetic|Structure_Match |\n|:-----------------------|---------:|---------:|--------------:|--------------:|:---------------|\n|Parametric MICE         |       299|        13|            299|             13|✅ Yes          |\n|CART Imputation         |       299|        13|            299|             13|✅ Yes          |\n|Synthpop (Low Fidelity) |       299|        13|            299|             13|✅ Yes          |\n|Metadata-Based          |       299|        13|            299|             13|✅ Yes          |\n\n\n:::\n:::\n\n\n\n\n\n### Categorical Variables: All Levels Maintained and Comparison of Distribution\n\nThis section evaluates how well the synthetic datasets replicate the categorical variables in the real dataset, focusing on the preservation of all levels and their distributions.\n\n- **Level Matching**: For each categorical variable, the synthetic dataset should retain all levels (categories) present in the real dataset. Missing levels suggest that the synthetic data may be incomplete, while additional levels could indicate errors in data generation.\n\n- **Distribution Comparison**: The frequency of each categorical level in the synthetic data should closely mirror that of the real dataset. Significant deviations in category frequencies suggest that the synthetic data does not fully capture the true distribution of the categorical features.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to collect categorical level info\nget_cat_levels <- function(real_data, synthetic_data, dataset_name) {\n  cat_vars <- colnames(real_data)[sapply(real_data, is.factor)]\n  \n  do.call(rbind, lapply(cat_vars, function(var) {\n    levels_real <- unique(real_data[[var]])\n    levels_synth <- unique(synthetic_data[[paste(\"synth\", var, sep = \"_\")]])\n    \n    data.frame(\n      Variable = var,\n      Dataset = dataset_name,\n      Real_Levels = paste(levels_real, collapse = \", \"),\n      Synthetic_Levels = paste(levels_synth, collapse = \", \"),\n      Match = ifelse(all(levels_real %in% levels_synth), \"✅ Yes\", \"❌ No\"),\n      stringsAsFactors = FALSE\n    )\n  }))\n}\n\n# Collect results\ncat_comparison <- bind_rows(\n  get_cat_levels(heart_failure, syn_data_1, \"Parametric MICE\"),\n  get_cat_levels(heart_failure, syn_cart_1, \"CART Imputation\"),\n  get_cat_levels(heart_failure, syn_data_low_fidelity_synthpop, \"Synthpop (Low Fidelity)\"),\n  get_cat_levels(heart_failure, syn_data_metadata, \"Metadata-Based\")\n)\n\n# Display table\nkable(cat_comparison,\n      caption = \"Comparison of Categorical Variable Levels in Real vs Synthetic Datasets\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Comparison of Categorical Variable Levels in Real vs Synthetic Datasets\n\n|Variable     |Dataset                 |Real_Levels  |Synthetic_Levels |Match  |\n|:------------|:-----------------------|:------------|:----------------|:------|\n|anaemia      |Parametric MICE         |No, Yes      |No, Yes          |✅ Yes |\n|diabetes     |Parametric MICE         |No, Yes      |No, Yes          |✅ Yes |\n|sex          |Parametric MICE         |Male, Female |Male, Female     |✅ Yes |\n|smoking      |Parametric MICE         |No, Yes      |Yes, No          |✅ Yes |\n|hypertension |Parametric MICE         |Yes, No      |Yes, No          |✅ Yes |\n|deceased     |Parametric MICE         |Yes, No      |Yes, No          |✅ Yes |\n|anaemia      |CART Imputation         |No, Yes      |No, Yes          |✅ Yes |\n|diabetes     |CART Imputation         |No, Yes      |No, Yes          |✅ Yes |\n|sex          |CART Imputation         |Male, Female |Female, Male     |✅ Yes |\n|smoking      |CART Imputation         |No, Yes      |Yes, No          |✅ Yes |\n|hypertension |CART Imputation         |Yes, No      |No, Yes          |✅ Yes |\n|deceased     |CART Imputation         |Yes, No      |Yes, No          |✅ Yes |\n|anaemia      |Synthpop (Low Fidelity) |No, Yes      |Yes, No          |✅ Yes |\n|diabetes     |Synthpop (Low Fidelity) |No, Yes      |No, Yes          |✅ Yes |\n|sex          |Synthpop (Low Fidelity) |Male, Female |Male, Female     |✅ Yes |\n|smoking      |Synthpop (Low Fidelity) |No, Yes      |Yes, No          |✅ Yes |\n|hypertension |Synthpop (Low Fidelity) |Yes, No      |Yes, No          |✅ Yes |\n|deceased     |Synthpop (Low Fidelity) |Yes, No      |Yes, No          |✅ Yes |\n|anaemia      |Metadata-Based          |No, Yes      |Yes, No          |✅ Yes |\n|diabetes     |Metadata-Based          |No, Yes      |Yes, No          |✅ Yes |\n|sex          |Metadata-Based          |Male, Female |Female, Male     |✅ Yes |\n|smoking      |Metadata-Based          |No, Yes      |Yes, No          |✅ Yes |\n|hypertension |Metadata-Based          |Yes, No      |Yes, No          |✅ Yes |\n|deceased     |Metadata-Based          |Yes, No      |No, Yes          |✅ Yes |\n\n\n:::\n:::\n\n\n\n\n\n### Numeric Variables: Range and Distribution Comparison\n\nThis analysis evaluates how well the numeric variables in the synthetic datasets replicate the real data in terms of range and distribution.\n\n- **Range**: For each numeric variable, the synthetic data should maintain values within the range of the real dataset. Any deviations, especially outliers, could indicate inaccuracies in the synthetic generation process.\n  \n- **Distribution Comparison**: Density plots are used to compare the shape of the distributions between the real and synthetic datasets. Ideally, the synthetic data should closely mirror the real distribution, indicating that the underlying data generation model has captured the true variability of the numeric features.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Helper: compute per-variable stats for a (real, synthetic) pair\nnumeric_summary <- function(real, synth, dataset_name) {\n  num_vars <- names(real)[sapply(real, is.numeric)]\n  # real percentiles\n  pctl <- map(num_vars, ~quantile(real[[.x]], probs = c(.05, .95), na.rm = TRUE)) |>\n    setNames(num_vars)\n\n  tibble(\n    Variable = num_vars,\n    Real_Min = map_dbl(num_vars, ~min(real[[.x]], na.rm = TRUE)),\n    Real_P5  = map_dbl(num_vars, ~pctl[[.x]][1]),\n    Real_P95 = map_dbl(num_vars, ~pctl[[.x]][2]),\n    Real_Max = map_dbl(num_vars, ~max(real[[.x]], na.rm = TRUE)),\n    Synth_Min = map_dbl(num_vars, ~min(synth[[paste0(\"synth_\", .x)]], na.rm = TRUE)),\n    Synth_Max = map_dbl(num_vars, ~max(synth[[paste0(\"synth_\", .x)]], na.rm = TRUE))\n  ) |>\n    mutate(\n      Within_P5_P95 = ifelse(Synth_Min >= Real_P5 & Synth_Max <= Real_P95, \"✅ Yes\", \"❌ No\"),\n      Dataset = dataset_name,\n      .before = 1\n    )\n}\n\n# Build one continuous table for all synthetic datasets\nnum_table <- bind_rows(\n  numeric_summary(heart_failure, syn_data_1, \"Parametric MICE\"),\n  numeric_summary(heart_failure, syn_cart_1, \"CART Imputation\"),\n  numeric_summary(heart_failure, syn_data_low_fidelity_synthpop, \"Synthpop (Low Fidelity)\"),\n  numeric_summary(heart_failure, syn_data_metadata, \"Metadata-Based\")\n)\n\nkable(\n  num_table,\n  caption = \"Numeric variables: real ranges & percentiles vs. synthetic ranges (with P5–P95 containment check)\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Numeric variables: real ranges & percentiles vs. synthetic ranges (with P5–P95 containment check)\n\n|Within_P5_P95 |Dataset                 |Variable                 | Real_Min|   Real_P5| Real_P95| Real_Max| Synth_Min| Synth_Max|\n|:-------------|:-----------------------|:------------------------|--------:|---------:|--------:|--------:|---------:|---------:|\n|❌ No         |Parametric MICE         |age                      |     40.0|     42.15|     82.0|     95.0|        42|        82|\n|❌ No         |Parametric MICE         |creatinine_phosphokinase |     23.0|     59.20|   2220.8|   7861.0|        59|      2221|\n|✅ Yes        |Parametric MICE         |ejection_fraction        |     14.0|     20.00|     60.0|     80.0|        20|        60|\n|✅ Yes        |Parametric MICE         |platelets                |  25100.0| 132200.00| 421200.0| 850000.0|    132200|    421200|\n|❌ No         |Parametric MICE         |serum_creatinine         |      0.5|      0.70|      2.9|      9.4|         1|         3|\n|✅ Yes        |Parametric MICE         |serum_sodium             |    113.0|    130.00|    144.0|    148.0|       130|       144|\n|✅ Yes        |Parametric MICE         |follow_up                |      4.0|     12.90|    250.0|    285.0|        13|       250|\n|❌ No         |CART Imputation         |age                      |     40.0|     42.15|     82.0|     95.0|        42|        82|\n|❌ No         |CART Imputation         |creatinine_phosphokinase |     23.0|     59.20|   2220.8|   7861.0|        59|      2221|\n|✅ Yes        |CART Imputation         |ejection_fraction        |     14.0|     20.00|     60.0|     80.0|        20|        60|\n|✅ Yes        |CART Imputation         |platelets                |  25100.0| 132200.00| 421200.0| 850000.0|    132200|    421200|\n|❌ No         |CART Imputation         |serum_creatinine         |      0.5|      0.70|      2.9|      9.4|         1|         3|\n|✅ Yes        |CART Imputation         |serum_sodium             |    113.0|    130.00|    144.0|    148.0|       130|       144|\n|✅ Yes        |CART Imputation         |follow_up                |      4.0|     12.90|    250.0|    285.0|        13|       250|\n|❌ No         |Synthpop (Low Fidelity) |age                      |     40.0|     42.15|     82.0|     95.0|        42|        82|\n|❌ No         |Synthpop (Low Fidelity) |creatinine_phosphokinase |     23.0|     59.20|   2220.8|   7861.0|        59|      2221|\n|✅ Yes        |Synthpop (Low Fidelity) |ejection_fraction        |     14.0|     20.00|     60.0|     80.0|        20|        60|\n|✅ Yes        |Synthpop (Low Fidelity) |platelets                |  25100.0| 132200.00| 421200.0| 850000.0|    132200|    421200|\n|❌ No         |Synthpop (Low Fidelity) |serum_creatinine         |      0.5|      0.70|      2.9|      9.4|         1|         3|\n|✅ Yes        |Synthpop (Low Fidelity) |serum_sodium             |    113.0|    130.00|    144.0|    148.0|       130|       144|\n|✅ Yes        |Synthpop (Low Fidelity) |follow_up                |      4.0|     12.90|    250.0|    285.0|        13|       250|\n|❌ No         |Metadata-Based          |age                      |     40.0|     42.15|     82.0|     95.0|        42|        82|\n|✅ Yes        |Metadata-Based          |creatinine_phosphokinase |     23.0|     59.20|   2220.8|   7861.0|        67|      2216|\n|✅ Yes        |Metadata-Based          |ejection_fraction        |     14.0|     20.00|     60.0|     80.0|        20|        60|\n|✅ Yes        |Metadata-Based          |platelets                |  25100.0| 132200.00| 421200.0| 850000.0|    134054|    421118|\n|❌ No         |Metadata-Based          |serum_creatinine         |      0.5|      0.70|      2.9|      9.4|         1|         3|\n|✅ Yes        |Metadata-Based          |serum_sodium             |    113.0|    130.00|    144.0|    148.0|       130|       144|\n|✅ Yes        |Metadata-Based          |follow_up                |      4.0|     12.90|    250.0|    285.0|        13|       249|\n\n\n:::\n:::\n\n\n\n\n\n### Missingness Comparison\n\nIn this section, we compare the proportions of missing values between the real dataset and each synthetic dataset. This comparison helps determine whether the synthetic datasets accurately represent the patterns of missingness in the real data.\n\n- **Missingness Proportions**: For each dataset, we calculate the proportion of missing values for every column and compare the results across the real and synthetic datasets.\n  \n- **Comparison Outcome**: Ideally, the synthetic datasets should exhibit similar missingness proportions to the real data. Any deviations may indicate differences in how missing values were handled during the synthetic data generation process.\n\n#### Introduction Plots\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Custom palette for the 5 metrics\nmetric_palette <- c(\n  \"Discrete Columns\"     = \"#B0D99B\",\n  \"Continuous Columns\"   = \"#528AA8\",\n  \"All Missing Columns\"  = \"#FFB6DB\",\n  \"Complete Rows\"        = \"#264653\",\n  \"Missing Observations\" = \"#2A9D8F\"\n)\n\n# Helper: strip 'synth_' for fair visuals\nstrip_synth_prefix <- function(df) { \n  names(df) <- sub(\"^synth_\", \"\", names(df)) \n  df \n}\n\n# Datasets to compare\ndatasets <- list(\n  \"Real Data\"               = heart_failure,\n  \"Parametric MICE\"         = strip_synth_prefix(syn_data_1),\n  \"CART Imputation\"         = strip_synth_prefix(syn_cart_1),\n  \"Synthpop (Low Fidelity)\" = strip_synth_prefix(syn_data_low_fidelity_synthpop),\n  \"Metadata-Based\"          = strip_synth_prefix(syn_data_metadata)\n)\n\n# Function: horizontal bar chart for the 5 metrics\nmake_intro_plot <- function(df, title) {\n  n_rows <- nrow(df)\n  n_cols <- ncol(df)\n\n  pct_discrete   <- 100 * sum(vapply(df, is.factor,  logical(1))) / n_cols\n  pct_continuous <- 100 * sum(vapply(df, is.numeric, logical(1))) / n_cols\n  pct_allmisscol <- 100 * sum(colSums(is.na(df)) == n_rows) / n_cols\n  pct_completer  <- 100 * sum(complete.cases(df)) / n_rows\n  pct_missobs    <- 100 * sum(is.na(df)) / (n_rows * n_cols)\n\n  plot_df <- tibble::tibble(\n    Metric = factor(\n      c(\"Discrete Columns\", \"Continuous Columns\", \"All Missing Columns\",\n        \"Complete Rows\", \"Missing Observations\"),\n      levels = rev(c(\"Discrete Columns\", \"Continuous Columns\", \"All Missing Columns\",\n                     \"Complete Rows\", \"Missing Observations\")) # reverse for nicer order\n    ),\n    Percentage = c(pct_discrete, pct_continuous, pct_allmisscol, pct_completer, pct_missobs)\n  )\n\n  ggplot(plot_df, aes(x = Percentage, y = Metric, fill = Metric)) +\n    geom_col(alpha = 0.9, show.legend = FALSE) +\n    geom_text(aes(label = paste0(round(Percentage, 1), \"%\")),\n              hjust = -0.1, size = 3.5) +\n    scale_x_continuous(\n      labels = scales::percent_format(scale = 1),\n      limits = c(0, 100),\n      expand = expansion(mult = c(0, 0.05)) # headroom for labels\n    ) +\n    scale_fill_manual(values = metric_palette) +\n    labs(title = title, x = \"Percentage\", y = NULL) +\n    theme_light() +\n    theme(\n      axis.text.y  = element_text(size = 9),\n      plot.title   = element_text(face = \"bold\")\n    )\n}\n\n# Build plots and combine in one grid\nwrap_plots(\n  imap(datasets, ~ make_intro_plot(.x, .y)),\n  ncol = 2\n) +\n  plot_annotation(\n    title = \"Dataset Overview: Discrete/Continuous Columns, All-Missing Columns, Complete Rows, Missing Observations\",\n    subtitle = \"Percentages shown per dataset; axes standardized to 0–100%\",\n    theme = theme(plot.title = element_text(face = \"bold\", size = 12))\n  )\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/intro-plots-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n#### Missingness Proportions and Comparison Outcome\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Helper: remove 'synth_' prefix so names match the real dataset\nstrip_synth_prefix <- function(df) {\n  names(df) <- sub(\"^synth_\", \"\", names(df))\n  df\n}\n\n# Compare against the real dataset's variable set\ncore_vars <- names(heart_failure)\n\n# Function to compute missingness proportions (2 d.p.) for one dataset\nget_missingness <- function(df, label) {\n  df2 <- df %>% strip_synth_prefix()\n  # keep only variables present in the real data (prevents mismatches)\n  df2 <- df2 %>% select(any_of(core_vars))\n  tibble(\n    Variable   = names(df2),\n    Proportion = round(colSums(is.na(df2)) / nrow(df2), 2),\n    Dataset    = label\n  )\n}\n\n# Build tidy table\nmissing_tbl <- bind_rows(\n  get_missingness(heart_failure, \"Real Data\"),\n  get_missingness(syn_data_1, \"Parametric MICE\"),\n  get_missingness(syn_cart_1, \"CART Imputation\"),\n  get_missingness(syn_data_low_fidelity_synthpop, \"Synthpop (Low Fidelity)\"),\n  get_missingness(syn_data_metadata, \"Metadata-Based\")\n)\n\n# Pivot wider for side-by-side comparison\nmissing_tbl_wide <- missing_tbl %>%\n  pivot_wider(names_from = Dataset, values_from = Proportion) %>%\n  arrange(Variable)\n\n# Optional: add quick match flags (✅ if identical to Real Data)\n# missing_tbl_wide <- missing_tbl_wide %>%\n#   mutate(\n#     `Parametric MICE Match` = ifelse(`Parametric MICE` == `Real Data`, \"✅\", \"❌\"),\n#     `CART Imputation Match` = ifelse(`CART Imputation` == `Real Data`, \"✅\", \"❌\"),\n#     `Synthpop (Low Fidelity) Match` = ifelse(`Synthpop (Low Fidelity)` == `Real Data`, \"✅\", \"❌\"),\n#     `Metadata-Based Match` = ifelse(`Metadata-Based` == `Real Data`, \"✅\", \"❌\")\n#   )\n\nkable(\n  missing_tbl_wide,\n  caption = \"Missingness Proportions by Variable (rounded to 2 d.p.)\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Missingness Proportions by Variable (rounded to 2 d.p.)\n\n|Variable                 | Real Data| Parametric MICE| CART Imputation| Synthpop (Low Fidelity)| Metadata-Based|\n|:------------------------|---------:|---------------:|---------------:|-----------------------:|--------------:|\n|age                      |      0.05|            0.05|            0.05|                    0.09|           0.05|\n|anaemia                  |      0.00|            0.00|            0.00|                    0.00|           0.00|\n|creatinine_phosphokinase |      0.05|            0.05|            0.05|                    0.10|           0.05|\n|deceased                 |      0.00|            0.00|            0.00|                    0.00|           0.00|\n|diabetes                 |      0.00|            0.00|            0.00|                    0.00|           0.00|\n|ejection_fraction        |      0.04|            0.04|            0.04|                    0.05|           0.04|\n|follow_up                |      0.00|            0.00|            0.00|                    0.00|           0.00|\n|hypertension             |      0.00|            0.00|            0.00|                    0.00|           0.00|\n|platelets                |      0.05|            0.05|            0.05|                    0.10|           0.05|\n|serum_creatinine         |      0.06|            0.06|            0.06|                    0.12|           0.06|\n|serum_sodium             |      0.07|            0.07|            0.07|                    0.11|           0.07|\n|sex                      |      0.00|            0.00|            0.00|                    0.00|           0.00|\n|smoking                  |      0.00|            0.00|            0.00|                    0.00|           0.00|\n\n\n:::\n:::\n\n\n\n\n\n#### Missingness Maps\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Generate missingness map for the real dataset\nreal_missing_map <- aggr(heart_failure, col = c(\"#B0D99B\", \"#528AA8\"),\n                             numbers = TRUE, sortVars = TRUE,\n                             labels = names(heart_failure), cex.axis = .7,\n                             gap = 3, ylab = c(\"Missing Data\", \"Pattern - real Dataset\"))\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Missingness Maps-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Variables sorted by number of missings: \n                 Variable      Count\n             serum_sodium 0.06688963\n         serum_creatinine 0.06020067\n                      age 0.05016722\n creatinine_phosphokinase 0.04682274\n                platelets 0.04682274\n        ejection_fraction 0.04013378\n                  anaemia 0.00000000\n                 diabetes 0.00000000\n                      sex 0.00000000\n                  smoking 0.00000000\n             hypertension 0.00000000\n                 deceased 0.00000000\n                follow_up 0.00000000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Generate missingness map for Parametric MICE synthetic dataset\nparametric_mice_missing_map <- aggr(syn_data_1, col = c(\"#B0D99B\", \"#528AA8\"),\n                                    numbers = TRUE, sortVars = TRUE,\n                                    labels = names(syn_data_1), cex.axis = .7,\n                                    gap = 3, ylab = c(\"Missing Data\", \"Pattern - Parametric MICE Dataset\"))\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Missingness Maps-2.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Variables sorted by number of missings: \n                       Variable      Count\n             synth_serum_sodium 0.06688963\n         synth_serum_creatinine 0.06020067\n                      synth_age 0.05016722\n synth_creatinine_phosphokinase 0.04682274\n                synth_platelets 0.04682274\n        synth_ejection_fraction 0.04013378\n                  synth_anaemia 0.00000000\n                 synth_diabetes 0.00000000\n                      synth_sex 0.00000000\n                  synth_smoking 0.00000000\n             synth_hypertension 0.00000000\n                 synth_deceased 0.00000000\n                synth_follow_up 0.00000000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Generate missingness map for CART synthetic dataset\ncart_missing_map <- aggr(syn_cart_1, col = c(\"#B0D99B\", \"#528AA8\"),\n                         numbers = TRUE, sortVars = TRUE,\n                         labels = names(syn_cart_1), cex.axis = .7,\n                         gap = 3, ylab = c(\"Missing Data\", \"Pattern - CART Dataset\"))\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Missingness Maps-3.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Variables sorted by number of missings: \n                       Variable      Count\n             synth_serum_sodium 0.06688963\n         synth_serum_creatinine 0.06020067\n                      synth_age 0.05016722\n synth_creatinine_phosphokinase 0.04682274\n                synth_platelets 0.04682274\n        synth_ejection_fraction 0.04013378\n                  synth_anaemia 0.00000000\n                 synth_diabetes 0.00000000\n                      synth_sex 0.00000000\n                  synth_smoking 0.00000000\n             synth_hypertension 0.00000000\n                 synth_deceased 0.00000000\n                synth_follow_up 0.00000000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Generate missingness map for Synthpop synthetic dataset\nsynthpop_missing_map <- aggr(syn_data_low_fidelity_synthpop, col = c(\"#B0D99B\", \"#528AA8\"),\n                             numbers = TRUE, sortVars = TRUE,\n                             labels = names(syn_data_low_fidelity_synthpop), cex.axis = .7,\n                             gap = 3, ylab = c(\"Missing Data\", \"Pattern - Synthpop Dataset\"))\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Missingness Maps-4.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Variables sorted by number of missings: \n                       Variable      Count\n         synth_serum_creatinine 0.11705686\n             synth_serum_sodium 0.11371237\n                synth_platelets 0.10367893\n synth_creatinine_phosphokinase 0.10033445\n                      synth_age 0.09364548\n        synth_ejection_fraction 0.04682274\n                  synth_anaemia 0.00000000\n                 synth_diabetes 0.00000000\n                      synth_sex 0.00000000\n                  synth_smoking 0.00000000\n             synth_hypertension 0.00000000\n                 synth_deceased 0.00000000\n                synth_follow_up 0.00000000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Generate missingness map for Metadata-based synthetic dataset\nmetadata_missing_map <- aggr(syn_data_metadata, col = c(\"#B0D99B\", \"#528AA8\"),\n                             numbers = TRUE, sortVars = TRUE,\n                             labels = names(syn_data_metadata), cex.axis = .7,\n                             gap = 3, ylab = c(\"Missing Data\", \"Pattern - Metadata-Based Dataset\"))\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Missingness Maps-5.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Variables sorted by number of missings: \n                       Variable      Count\n             synth_serum_sodium 0.06688963\n         synth_serum_creatinine 0.06020067\n                      synth_age 0.05016722\n synth_creatinine_phosphokinase 0.04682274\n                synth_platelets 0.04682274\n        synth_ejection_fraction 0.04013378\n                  synth_anaemia 0.00000000\n                 synth_diabetes 0.00000000\n                      synth_sex 0.00000000\n                  synth_smoking 0.00000000\n             synth_hypertension 0.00000000\n                 synth_deceased 0.00000000\n                synth_follow_up 0.00000000\n```\n\n\n:::\n:::\n\n\n\n\n\n### Correlation Matrices Comparison\n\nIn this section, we assess how well the correlations between numeric variables are preserved in the synthetic datasets compared to the real dataset. By comparing the correlation matrices, we evaluate whether the relationships between variables in the real data are reflected in the synthetic versions. This assessment is essential because maintaining the real data's correlation structure ensures that any statistical or machine learning models trained on synthetic data will behave similarly to those trained on real data.\n\n- **Correlation Matrix**: A correlation matrix quantifies the strength and direction of relationships between pairs of numeric variables. Each cell in the matrix represents the correlation coefficient between two variables, which can range from -1 (perfect negative correlation) to +1 (perfect positive correlation). It is crucial that synthetic data retains these relationships to ensure that any analyses based on these dependencies remain valid.\n\n- **Comparison Process**: The correlation matrices for both the real and synthetic datasets are computed and Visualised. Ideally, the structure and strength of correlations in the synthetic datasets should closely match those in the real dataset. Differences in correlation strength or direction indicate that the synthetic data may not fully capture the underlying relationships, which can affect the validity of any conclusions drawn from analyses using the synthetic data.\n\nMaintaining similar correlation structures is particularly important for use cases where relationships between variables play a crucial role, such as in predictive modeling, feature selection, and understanding variable dependencies. The following sections outline different methods used to compare correlation matrices between the real and synthetic datasets.\n\n#### Correlation Matrices Comparison using psych\n\nThe `psych` package provides tools for analyzing and visualizing correlation matrices. The `corr.test()` function is particularly useful for computing correlation coefficients while handling missing data and providing additional statistics, such as confidence intervals.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Helper: strip 'synth_' so names line up with real\nstrip_synth_prefix <- function(df) {\n  names(df) <- sub(\"^synth_\", \"\", names(df))\n  df\n}\n\n# Build a tidy table of pairwise correlations for real vs one synthetic dataset\ncorr_compare_one <- function(real, synth, label) {\n  real_num  <- real |> select(where(is.numeric))\n  synth_num <- synth |> strip_synth_prefix() |> select(where(is.numeric))\n\n  common <- intersect(names(real_num), names(synth_num))\n  if (length(common) < 2) {\n    return(tibble(Dataset = label, Var1 = character(), Var2 = character(),\n                  Real = numeric(), Synthetic = numeric(), Diff = numeric(), AbsDiff = numeric()))\n  }\n\n  # Compute Pearson correlations with pairwise complete observations\n  rc <- cor(real_num[common],  use = \"pairwise.complete.obs\", method = \"pearson\")\n  sc <- cor(synth_num[common], use = \"pairwise.complete.obs\", method = \"pearson\")\n\n  # Keep only upper triangle (unique pairs)\n  ut <- upper.tri(rc, diag = FALSE)\n  pairs <- which(ut, arr.ind = TRUE)\n  tibble(\n    Var1 = colnames(rc)[pairs[, 1]],\n    Var2 = colnames(rc)[pairs[, 2]],\n    Real = rc[pairs],\n    Synthetic = sc[pairs]\n  ) |>\n    mutate(\n      Dataset = label,\n      Diff = Synthetic - Real,\n      AbsDiff = abs(Diff)\n    ) |>\n    select(Dataset, Var1, Var2, Real, Synthetic, Diff, AbsDiff)\n}\n\n# Build one combined table for all synthetic datasets\ncorr_cmp_tbl <- bind_rows(\n  corr_compare_one(heart_failure, syn_data_1, \"Parametric MICE\"),\n  corr_compare_one(heart_failure, syn_cart_1, \"CART Imputation\"),\n  corr_compare_one(heart_failure, syn_data_low_fidelity_synthpop, \"Synthpop (Low Fidelity)\"),\n  corr_compare_one(heart_failure, syn_data_metadata, \"Metadata-Based\")\n) |>\n  arrange(Dataset, desc(AbsDiff)) |>\n  mutate(\n    Real = round(Real, 2),\n    Synthetic = round(Synthetic, 2),\n    Diff = round(Diff, 2),\n    AbsDiff = round(AbsDiff, 2)\n  )\n\nknitr::kable(\n  corr_cmp_tbl,\n  caption = \"Pairwise Correlations: Real vs. Synthetic (sorted by largest absolute difference per dataset)\",\n  align = \"lllrrrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Pairwise Correlations: Real vs. Synthetic (sorted by largest absolute difference per dataset)\n\n|Dataset                 |Var1                     |Var2                     |  Real| Synthetic|  Diff| AbsDiff|\n|:-----------------------|:------------------------|:------------------------|-----:|---------:|-----:|-------:|\n|CART Imputation         |creatinine_phosphokinase |platelets                |  0.01|     -0.12| -0.13|    0.13|\n|CART Imputation         |ejection_fraction        |serum_creatinine         | -0.01|     -0.11| -0.10|    0.10|\n|CART Imputation         |creatinine_phosphokinase |serum_sodium             |  0.06|     -0.04| -0.10|    0.10|\n|CART Imputation         |age                      |follow_up                | -0.24|     -0.15|  0.09|    0.09|\n|CART Imputation         |ejection_fraction        |platelets                |  0.06|     -0.02| -0.08|    0.08|\n|CART Imputation         |age                      |serum_creatinine         |  0.17|      0.25|  0.08|    0.08|\n|CART Imputation         |platelets                |serum_creatinine         | -0.05|      0.03|  0.08|    0.08|\n|CART Imputation         |ejection_fraction        |follow_up                |  0.03|     -0.05| -0.08|    0.08|\n|CART Imputation         |serum_sodium             |follow_up                |  0.11|      0.03| -0.07|    0.07|\n|CART Imputation         |age                      |creatinine_phosphokinase | -0.08|     -0.15| -0.07|    0.07|\n|CART Imputation         |platelets                |serum_sodium             |  0.06|     -0.01| -0.07|    0.07|\n|CART Imputation         |creatinine_phosphokinase |follow_up                | -0.03|      0.03|  0.06|    0.06|\n|CART Imputation         |platelets                |follow_up                | -0.01|      0.05|  0.06|    0.06|\n|CART Imputation         |age                      |platelets                | -0.05|     -0.01|  0.04|    0.04|\n|CART Imputation         |age                      |serum_sodium             | -0.04|     -0.08| -0.04|    0.04|\n|CART Imputation         |age                      |ejection_fraction        |  0.04|      0.00| -0.04|    0.04|\n|CART Imputation         |creatinine_phosphokinase |ejection_fraction        | -0.05|     -0.02|  0.03|    0.03|\n|CART Imputation         |creatinine_phosphokinase |serum_creatinine         |  0.00|     -0.02| -0.02|    0.02|\n|CART Imputation         |serum_creatinine         |serum_sodium             | -0.21|     -0.23| -0.02|    0.02|\n|CART Imputation         |ejection_fraction        |serum_sodium             |  0.17|      0.18|  0.02|    0.02|\n|CART Imputation         |serum_creatinine         |follow_up                | -0.15|     -0.14|  0.01|    0.01|\n|Metadata-Based          |age                      |follow_up                | -0.24|      0.12|  0.36|    0.36|\n|Metadata-Based          |platelets                |serum_sodium             |  0.06|     -0.16| -0.23|    0.23|\n|Metadata-Based          |serum_creatinine         |serum_sodium             | -0.21|      0.01|  0.21|    0.21|\n|Metadata-Based          |creatinine_phosphokinase |ejection_fraction        | -0.05|      0.11|  0.16|    0.16|\n|Metadata-Based          |ejection_fraction        |serum_sodium             |  0.17|      0.03| -0.13|    0.13|\n|Metadata-Based          |creatinine_phosphokinase |serum_creatinine         |  0.00|     -0.12| -0.13|    0.13|\n|Metadata-Based          |creatinine_phosphokinase |follow_up                | -0.03|      0.09|  0.12|    0.12|\n|Metadata-Based          |age                      |serum_creatinine         |  0.17|      0.07| -0.10|    0.10|\n|Metadata-Based          |serum_sodium             |follow_up                |  0.11|      0.00| -0.10|    0.10|\n|Metadata-Based          |age                      |serum_sodium             | -0.04|      0.06|  0.10|    0.10|\n|Metadata-Based          |serum_creatinine         |follow_up                | -0.15|     -0.05|  0.09|    0.09|\n|Metadata-Based          |creatinine_phosphokinase |platelets                |  0.01|     -0.08| -0.09|    0.09|\n|Metadata-Based          |ejection_fraction        |platelets                |  0.06|     -0.02| -0.08|    0.08|\n|Metadata-Based          |age                      |platelets                | -0.05|      0.02|  0.07|    0.07|\n|Metadata-Based          |age                      |ejection_fraction        |  0.04|     -0.03| -0.07|    0.07|\n|Metadata-Based          |ejection_fraction        |follow_up                |  0.03|      0.08|  0.05|    0.05|\n|Metadata-Based          |creatinine_phosphokinase |serum_sodium             |  0.06|      0.11|  0.05|    0.05|\n|Metadata-Based          |age                      |creatinine_phosphokinase | -0.08|     -0.05|  0.03|    0.03|\n|Metadata-Based          |ejection_fraction        |serum_creatinine         | -0.01|      0.01|  0.02|    0.02|\n|Metadata-Based          |platelets                |follow_up                | -0.01|     -0.02| -0.01|    0.01|\n|Metadata-Based          |platelets                |serum_creatinine         | -0.05|     -0.06| -0.01|    0.01|\n|Parametric MICE         |serum_creatinine         |serum_sodium             | -0.21|      0.02|  0.23|    0.23|\n|Parametric MICE         |ejection_fraction        |follow_up                |  0.03|      0.20|  0.17|    0.17|\n|Parametric MICE         |age                      |follow_up                | -0.24|     -0.08|  0.16|    0.16|\n|Parametric MICE         |ejection_fraction        |serum_sodium             |  0.17|      0.03| -0.13|    0.13|\n|Parametric MICE         |serum_sodium             |follow_up                |  0.11|     -0.01| -0.11|    0.11|\n|Parametric MICE         |platelets                |serum_creatinine         | -0.05|      0.06|  0.11|    0.11|\n|Parametric MICE         |creatinine_phosphokinase |serum_creatinine         |  0.00|     -0.11| -0.11|    0.11|\n|Parametric MICE         |age                      |serum_creatinine         |  0.17|      0.08| -0.09|    0.09|\n|Parametric MICE         |creatinine_phosphokinase |platelets                |  0.01|     -0.07| -0.08|    0.08|\n|Parametric MICE         |age                      |serum_sodium             | -0.04|     -0.11| -0.07|    0.07|\n|Parametric MICE         |age                      |creatinine_phosphokinase | -0.08|     -0.02|  0.06|    0.06|\n|Parametric MICE         |creatinine_phosphokinase |follow_up                | -0.03|      0.03|  0.06|    0.06|\n|Parametric MICE         |platelets                |follow_up                | -0.01|      0.04|  0.05|    0.05|\n|Parametric MICE         |creatinine_phosphokinase |ejection_fraction        | -0.05|     -0.01|  0.04|    0.04|\n|Parametric MICE         |serum_creatinine         |follow_up                | -0.15|     -0.11|  0.04|    0.04|\n|Parametric MICE         |platelets                |serum_sodium             |  0.06|      0.03| -0.03|    0.03|\n|Parametric MICE         |creatinine_phosphokinase |serum_sodium             |  0.06|      0.03| -0.03|    0.03|\n|Parametric MICE         |ejection_fraction        |serum_creatinine         | -0.01|     -0.04| -0.03|    0.03|\n|Parametric MICE         |age                      |platelets                | -0.05|     -0.03|  0.02|    0.02|\n|Parametric MICE         |age                      |ejection_fraction        |  0.04|      0.05|  0.01|    0.01|\n|Parametric MICE         |ejection_fraction        |platelets                |  0.06|      0.06|  0.00|    0.00|\n|Synthpop (Low Fidelity) |age                      |follow_up                | -0.24|      0.04|  0.28|    0.28|\n|Synthpop (Low Fidelity) |serum_creatinine         |serum_sodium             | -0.21|      0.00|  0.20|    0.20|\n|Synthpop (Low Fidelity) |age                      |serum_creatinine         |  0.17|     -0.03| -0.20|    0.20|\n|Synthpop (Low Fidelity) |ejection_fraction        |serum_sodium             |  0.17|     -0.02| -0.19|    0.19|\n|Synthpop (Low Fidelity) |age                      |serum_sodium             | -0.04|      0.11|  0.15|    0.15|\n|Synthpop (Low Fidelity) |serum_creatinine         |follow_up                | -0.15|      0.00|  0.15|    0.15|\n|Synthpop (Low Fidelity) |serum_sodium             |follow_up                |  0.11|     -0.03| -0.14|    0.14|\n|Synthpop (Low Fidelity) |age                      |creatinine_phosphokinase | -0.08|      0.03|  0.12|    0.12|\n|Synthpop (Low Fidelity) |creatinine_phosphokinase |ejection_fraction        | -0.05|      0.05|  0.10|    0.10|\n|Synthpop (Low Fidelity) |ejection_fraction        |platelets                |  0.06|      0.15|  0.09|    0.09|\n|Synthpop (Low Fidelity) |platelets                |follow_up                | -0.01|      0.08|  0.09|    0.09|\n|Synthpop (Low Fidelity) |ejection_fraction        |follow_up                |  0.03|      0.09|  0.06|    0.06|\n|Synthpop (Low Fidelity) |creatinine_phosphokinase |platelets                |  0.01|     -0.05| -0.06|    0.06|\n|Synthpop (Low Fidelity) |age                      |ejection_fraction        |  0.04|     -0.02| -0.06|    0.06|\n|Synthpop (Low Fidelity) |ejection_fraction        |serum_creatinine         | -0.01|     -0.06| -0.05|    0.05|\n|Synthpop (Low Fidelity) |creatinine_phosphokinase |serum_sodium             |  0.06|      0.01| -0.05|    0.05|\n|Synthpop (Low Fidelity) |creatinine_phosphokinase |follow_up                | -0.03|      0.02|  0.04|    0.04|\n|Synthpop (Low Fidelity) |platelets                |serum_creatinine         | -0.05|     -0.08| -0.03|    0.03|\n|Synthpop (Low Fidelity) |creatinine_phosphokinase |serum_creatinine         |  0.00|     -0.02| -0.03|    0.03|\n|Synthpop (Low Fidelity) |platelets                |serum_sodium             |  0.06|      0.08|  0.02|    0.02|\n|Synthpop (Low Fidelity) |age                      |platelets                | -0.05|     -0.04|  0.01|    0.01|\n\n\n:::\n:::\n\n\n\n\n\n#### Correlation Matrices Comparison using Corrplot\n\nThe `corrplot` package is widely used for visualizing correlation matrices. It provides a variety of options for customization, making it easy to identify patterns and relationships between variables. This method is particularly effective for visual comparisons because it highlights differences in correlation strength and direction.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Helper: remove 'synth_' so names match the real dataset\nstrip_synth_prefix <- function(df) { names(df) <- sub(\"^synth_\", \"\", names(df)); df }\n\n# Side-by-side correlation matrices (full width)\ncompare_correlation_matrices <- function(real_data, synthetic_data, dataset_name) {\n  # Numeric-only\n  real_num  <- real_data[sapply(real_data, is.numeric)]\n  synth_num <- strip_synth_prefix(synthetic_data)[sapply(strip_synth_prefix(synthetic_data), is.numeric)]\n\n  # Use common numeric variables in same order\n  common <- intersect(names(real_num), names(synth_num))\n  if (length(common) < 2) {\n    message(dataset_name, \": fewer than 2 common numeric columns — skipping.\")\n    return(invisible(NULL))\n  }\n  real_corr  <- cor(real_num[common],  use = \"complete.obs\")\n  synth_corr <- cor(synth_num[common], use = \"complete.obs\")\n\n  # Make two panels across the page\n  op <- par(no.readonly = TRUE); on.exit(par(op), add = TRUE)\n  par(mfrow = c(1, 2), mar = c(4, 4, 4, 2))\n\n  corrplot(real_corr,  tl.cex = 0.8, mar = c(0,0,2,0))\n  title(paste(dataset_name, \"- Real Data\"), line = 1)\n\n  corrplot(synth_corr, tl.cex = 0.8, mar = c(0,0,2,0))\n  title(paste(dataset_name, \"- Synthetic Data\"), line = 1)\n}\n\n# Run for each synthetic dataset\ncompare_correlation_matrices(heart_failure, syn_data_1, \"Parametric MICE\")\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Correlation Matrices Comparison using Corrplot-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n```{.r .cell-code}\ncompare_correlation_matrices(heart_failure, syn_cart_1, \"CART Imputation\")\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Correlation Matrices Comparison using Corrplot-2.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n```{.r .cell-code}\ncompare_correlation_matrices(heart_failure, syn_data_low_fidelity_synthpop, \"Synthpop (Low Fidelity)\")\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Correlation Matrices Comparison using Corrplot-3.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n```{.r .cell-code}\ncompare_correlation_matrices(heart_failure, syn_data_metadata, \"Metadata-Based\")\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Correlation Matrices Comparison using Corrplot-4.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n#### Correlation Matrices Comparison using GGally\n\nThe `GGally` package extends `ggplot2` to create pairwise visualizations, including correlation matrix plots. Using `ggpairs()`, you can generate a matrix of scatterplots, histograms, and correlation coefficients, which provides a detailed view of the relationships between numeric variables in the real and synthetic datasets.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncompare_correlation_matrices_ggally <- function(real_data, synthetic_data, dataset_name) {\n\n  # Select only numeric columns from both datasets\n  real_numeric <- real_data %>% select(where(is.numeric))\n\n  # Remove prefix 'synth_' from synthetic data column names\n  names(synthetic_data) <- gsub(\"^synth_\", \"\", names(synthetic_data))\n  synthetic_numeric <- synthetic_data %>% select(where(is.numeric))\n\n  # Ensure that both datasets have the same columns\n  common_columns <- intersect(names(real_numeric), names(synthetic_numeric))\n  \n  if (length(common_columns) == 0) {\n    cat(\"\\nNo common numeric columns found for comparison in\", dataset_name, \"\\n\")\n    return()\n  }\n\n  real_numeric <- real_numeric[, common_columns, drop = FALSE]\n  synthetic_numeric <- synthetic_numeric[, common_columns, drop = FALSE]\n\n  # Add a column to differentiate between real and synthetic data\n  real_numeric$Dataset <- \"Real\"\n  synthetic_numeric$Dataset <- \"Synth\"\n\n  # Combine the datasets\n  combined_data <- rbind(real_numeric, synthetic_numeric)\n\n  # Create correlation matrix plot using GGally if there are valid columns to plot\n  if (ncol(combined_data) > 1) {\n    p <- ggpairs(\n      combined_data, \n      aes(color = Dataset, alpha = 0.5), \n      title = paste(dataset_name, \"- Correlation Matrix Comparison\"),\n      columns = 1:(ncol(combined_data) - 1),  # Exclude the 'Dataset' column from the plot\n      upper = list(continuous = wrap(\"cor\", size = 3, alignPercent = 0.5)),  # Smaller correlation labels\n      lower = list(continuous = wrap(\"smooth\", alpha = 0.4, size = 0.5)),  # Smoother plots for readability\n      diag = list(continuous = wrap(\"densityDiag\", alpha = 0.5))  # Density plot with improved transparency\n    ) +\n      theme_minimal() +  # Use a cleaner theme\n      theme(\n        strip.text = element_text(size = 8, face = \"bold\"),  # Smaller strip labels\n        axis.text.x = element_text(angle = 45, hjust = 1, size = 7),  # Rotate x-axis labels for better readability\n        axis.text.y = element_text(size = 7),\n        legend.position = \"top\",  # Move legend to a better location\n        legend.title = element_blank()  # Remove unnecessary legend title\n      )\n    print(p)\n  } else {\n    cat(\"\\nNot enough numeric columns to generate a correlation matrix plot for\", dataset_name, \"\\n\")\n  }\n}\n\n# Apply the function to each synthetic dataset\ncompare_correlation_matrices_ggally(heart_failure, syn_data_1, \"Parametric MICE\")\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Correlation Matrices Comparison using GGally-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n```{.r .cell-code}\ncompare_correlation_matrices_ggally(heart_failure, syn_cart_1, \"CART Imputation\")\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Correlation Matrices Comparison using GGally-2.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n```{.r .cell-code}\ncompare_correlation_matrices_ggally(heart_failure, syn_data_low_fidelity_synthpop, \"Synthpop Low Fidelity\")\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Correlation Matrices Comparison using GGally-3.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n```{.r .cell-code}\ncompare_correlation_matrices_ggally(heart_failure, syn_data_metadata, \"Metadata-Based Synthetic Data\")\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Correlation Matrices Comparison using GGally-4.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n## Fidelity Assessment\n\n### Descriptive Statistics\n\nThis section provides a comparative analysis of the descriptive statistics between the real dataset and the synthetic datasets generated using different methods.\n\n#### Real Dataset\n\nThe descriptive statistics for the real heart failure dataset include metrics such as mean, median, standard deviation, and range. This serves as the baseline for comparison with the synthetic datasets.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate descriptive stats\ndesc_tbl <- describe(heart_failure) %>%\n  as.data.frame() %>%\n  select(n, mean, sd, min, median, max) %>%\n  round(2) %>%\n  tibble::rownames_to_column(\"Variable\")\n\n# Display as a neat table\nkable(\n  desc_tbl,\n  caption = \"Descriptive Statistics for the Heart Failure Dataset\",\n  align = \"lrrrrrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Descriptive Statistics for the Heart Failure Dataset\n\n|Variable                 |   n|      mean|       sd|     min|   median|      max|\n|:------------------------|---:|---------:|--------:|-------:|--------:|--------:|\n|age                      | 284|     60.80|    12.08|    40.0|     60.0|     95.0|\n|anaemia*                 | 299|      1.43|     0.50|     1.0|      1.0|      2.0|\n|creatinine_phosphokinase | 285|    578.81|   981.99|    23.0|    249.0|   7861.0|\n|diabetes*                | 299|      1.42|     0.49|     1.0|      1.0|      2.0|\n|ejection_fraction        | 287|     38.00|    11.92|    14.0|     38.0|     80.0|\n|platelets                | 285| 265163.83| 97508.63| 25100.0| 263358.0| 850000.0|\n|serum_creatinine         | 281|      1.39|     1.05|     0.5|      1.1|      9.4|\n|serum_sodium             | 279|    136.59|     4.49|   113.0|    137.0|    148.0|\n|sex*                     | 299|      1.65|     0.48|     1.0|      2.0|      2.0|\n|smoking*                 | 299|      1.32|     0.47|     1.0|      1.0|      2.0|\n|hypertension*            | 299|      1.35|     0.48|     1.0|      1.0|      2.0|\n|deceased*                | 299|      1.32|     0.47|     1.0|      1.0|      2.0|\n|follow_up                | 299|    130.26|    77.61|     4.0|    115.0|    285.0|\n\n\n:::\n:::\n\n\n\n\n\n#### Parametric Imputation (MICE)\n\nThe synthetic data generated using the MICE framework is analyzed to compare its summary statistics with the real dataset. This will help evaluate how well the parametric method captures the key characteristics of the data.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Descriptive stats for Parametric MICE synthetic dataset\ndesc_mice <- describe(syn_data_1) %>%\n  as.data.frame() %>%\n  select(n, mean, sd, min, median, max) %>%\n  round(2) %>%\n  tibble::rownames_to_column(\"Variable\")\n\n# Display table\nkable(\n  desc_mice,\n  caption = \"Descriptive Statistics for Parametric MICE Synthetic Dataset\",\n  align = \"lrrrrrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Descriptive Statistics for Parametric MICE Synthetic Dataset\n\n|Variable                       |   n|      mean|       sd|    min| median|    max|\n|:------------------------------|---:|---------:|--------:|------:|------:|------:|\n|synth_age                      | 284|     61.01|    11.40|     42|     60|     82|\n|synth_anaemia*                 | 299|      1.45|     0.50|      1|      1|      2|\n|synth_creatinine_phosphokinase | 285|    735.72|   687.98|     59|    540|   2221|\n|synth_diabetes*                | 299|      1.42|     0.49|      1|      1|      2|\n|synth_ejection_fraction        | 287|     38.44|    10.70|     20|     38|     60|\n|synth_platelets                | 285| 257523.78| 86505.14| 132200| 254087| 421200|\n|synth_serum_creatinine         | 281|      1.70|     0.77|      1|      2|      3|\n|synth_serum_sodium             | 279|    135.78|     3.96|    130|    135|    144|\n|synth_sex*                     | 299|      1.64|     0.48|      1|      2|      2|\n|synth_smoking*                 | 299|      1.29|     0.45|      1|      1|      2|\n|synth_hypertension*            | 299|      1.42|     0.49|      1|      1|      2|\n|synth_deceased*                | 299|      1.31|     0.47|      1|      1|      2|\n|synth_follow_up                | 299|    132.74|    71.11|     13|    132|    250|\n\n\n:::\n:::\n\n\n\n\n\n#### Non-Parametric Imputation (CART)\n\nThe CART method is a non-parametric technique that handles non-linear relationships. The descriptive statistics of the CART-imputed synthetic data provide insight into how this method captures the dataset's distribution.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Descriptive stats for CART synthetic dataset\ndesc_cart <- describe(syn_cart_1) %>%\n  as.data.frame() %>%\n  select(n, mean, sd, min, median, max) %>%\n  round(2) %>%\n  tibble::rownames_to_column(\"Variable\")\n\n# Display table\nkable(\n  desc_cart,\n  caption = \"Descriptive Statistics for CART Synthetic Dataset\",\n  align = \"lrrrrrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Descriptive Statistics for CART Synthetic Dataset\n\n|Variable                       |   n|      mean|       sd|    min| median|    max|\n|:------------------------------|---:|---------:|--------:|------:|------:|------:|\n|synth_age                      | 284|     60.81|    11.88|     42|     60|     82|\n|synth_anaemia*                 | 299|      1.42|     0.49|      1|      1|      2|\n|synth_creatinine_phosphokinase | 285|    469.20|   547.58|     59|    231|   2221|\n|synth_diabetes*                | 299|      1.46|     0.50|      1|      1|      2|\n|synth_ejection_fraction        | 287|     38.56|    11.85|     20|     35|     60|\n|synth_platelets                | 285| 265126.32| 76944.75| 132200| 263358| 421200|\n|synth_serum_creatinine         | 281|      1.28|     0.56|      1|      1|      3|\n|synth_serum_sodium             | 279|    136.79|     3.67|    130|    137|    144|\n|synth_sex*                     | 299|      1.67|     0.47|      1|      2|      2|\n|synth_smoking*                 | 299|      1.37|     0.48|      1|      1|      2|\n|synth_hypertension*            | 299|      1.38|     0.49|      1|      1|      2|\n|synth_deceased*                | 299|      1.33|     0.47|      1|      1|      2|\n|synth_follow_up                | 299|    132.53|    75.17|     13|    117|    250|\n\n\n:::\n:::\n\n\n\n\n\n#### Synthpop-Based Synthetic Data\n\nThe Synthpop package generates synthetic data aimed at preserving data privacy. Descriptive statistics for this dataset help assess how well the key attributes of the real data are preserved.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Descriptive stats for Synthpop synthetic dataset\ndesc_synthpop <- describe(syn_data_low_fidelity_synthpop) %>%\n  as.data.frame() %>%\n  select(n, mean, sd, min, median, max) %>%\n  round(2) %>%\n  tibble::rownames_to_column(\"Variable\")\n\n# Display as a clean table\nkable(\n  desc_synthpop,\n  caption = \"Descriptive Statistics for Synthpop Synthetic Dataset\",\n  align = \"lrrrrrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Descriptive Statistics for Synthpop Synthetic Dataset\n\n|Variable                       |   n|      mean|       sd|    min| median|    max|\n|:------------------------------|---:|---------:|--------:|------:|------:|------:|\n|synth_age                      | 271|     61.15|    11.13|     42|     60|     82|\n|synth_anaemia*                 | 299|      1.47|     0.50|      1|      1|      2|\n|synth_creatinine_phosphokinase | 269|    435.35|   498.44|     59|    232|   2221|\n|synth_diabetes*                | 299|      1.37|     0.48|      1|      1|      2|\n|synth_ejection_fraction        | 285|     36.73|    10.93|     20|     35|     60|\n|synth_platelets                | 268| 269756.34| 77738.41| 132200| 263358| 421200|\n|synth_serum_creatinine         | 264|      1.33|     0.63|      1|      1|      3|\n|synth_serum_sodium             | 265|    136.92|     3.69|    130|    137|    144|\n|synth_sex*                     | 299|      1.65|     0.48|      1|      2|      2|\n|synth_smoking*                 | 299|      1.28|     0.45|      1|      1|      2|\n|synth_hypertension*            | 299|      1.37|     0.48|      1|      1|      2|\n|synth_deceased*                | 299|      1.31|     0.46|      1|      1|      2|\n|synth_follow_up                | 299|    121.22|    74.28|     13|    108|    250|\n\n\n:::\n:::\n\n\n\n\n\n#### Metadata-Based Synthetic Data\n\nThe synthetic data generated using metadata ensures that variable structures conform to the data dictionary. The summary statistics here show how well the dataset reflects the real's attributes based on predefined metadata.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Descriptive stats for Metadata-Based synthetic dataset\ndesc_metadata <- describe(syn_data_metadata) %>%\n  as.data.frame() %>%\n  select(n, mean, sd, min, median, max) %>%\n  round(2) %>%\n  tibble::rownames_to_column(\"Variable\")\n\n# Display as a clean table\nkable(\n  desc_metadata,\n  caption = \"Descriptive Statistics for Metadata-Based Synthetic Dataset\",\n  align = \"lrrrrrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Descriptive Statistics for Metadata-Based Synthetic Dataset\n\n|Variable                       |   n|      mean|       sd|    min|   median|    max|\n|:------------------------------|---:|---------:|--------:|------:|--------:|------:|\n|synth_age                      | 284|     62.57|    11.98|     42|     62.5|     82|\n|synth_anaemia*                 | 299|      1.52|     0.50|      1|      2.0|      2|\n|synth_creatinine_phosphokinase | 285|   1129.11|   594.90|     67|   1185.0|   2216|\n|synth_diabetes*                | 299|      1.48|     0.50|      1|      1.0|      2|\n|synth_ejection_fraction        | 287|     39.81|    12.08|     20|     38.0|     60|\n|synth_platelets                | 285| 275686.74| 79876.34| 134054| 280442.0| 421118|\n|synth_serum_creatinine         | 281|      1.79|     0.71|      1|      2.0|      3|\n|synth_serum_sodium             | 279|    136.69|     4.20|    130|    137.0|    144|\n|synth_sex*                     | 299|      1.49|     0.50|      1|      1.0|      2|\n|synth_smoking*                 | 299|      1.51|     0.50|      1|      2.0|      2|\n|synth_hypertension*            | 299|      1.51|     0.50|      1|      2.0|      2|\n|synth_deceased*                | 299|      1.47|     0.50|      1|      1.0|      2|\n|synth_follow_up                | 299|    136.77|    70.26|     13|    139.0|    249|\n\n\n:::\n:::\n\n\n\n\n\nBy comparing the descriptive statistics, you can evaluate how closely the synthetic datasets resemble the real dataset across key summary metrics. This is a critical step in assessing the quality and usability of synthetic data.\nHistogram Similarity Score\n### Variable Exploration\n\n#### Parametric Imputation (MICE)\n\nThe parametric imputation using the MICE framework generates synthetic data by imputing missing values based on multivariate normal distributions.\n\n##### Bar Plots for Categorical Variables\n\nTo evaluate the preservation of categorical variable distributions in the synthetic data, we generate bar plots comparing the proportions of categorical variables between the real and synthetic datasets.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Combine real and parametric MICE synthetic datasets\nheart_failure$dataset <- \"real\"\nsyn_data_1$dataset <- \"synthetic\"\n\n# Adjust the column names for synthetic data by removing the 'synth_' prefix\ncolnames(syn_data_1) <- gsub(\"synth_\", \"\", colnames(syn_data_1))\n\n# Combine both datasets (real and synthetic)\ncombined_data_param <- bind_rows(heart_failure, syn_data_1)\n\n# Bar plots for categorical variables\nbar_plots <- colnames(heart_failure)[map_lgl(heart_failure, is.factor)] %>%\n  map(~ ggplot(combined_data_param, aes_string(.x, fill = 'dataset', group = 'dataset')) +\n        geom_bar(aes(y = ..prop..), position = position_dodge2(), stat = \"count\") +\n        scale_fill_manual(values = c(\"real\" = \"#B0D99B\", \"synthetic\" = \"#528AA8\")) +\n        labs(x = .x, y = \"Proportion\")) %>%\n  patchwork::wrap_plots() +\n  plot_annotation(title = \"Comparison of Categorical Variables Between real and Synthetic Datasets\",\n                  theme = theme(plot.title = element_text(hjust = 0.5)))\n\n# Print the combined plot with one main title\nprint(bar_plots)\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Bar Plots for Categorical Variables-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n##### Density Plots for Numeric Variables\n\nThe density plots illustrate the distribution of numeric variables between the real dataset and the parametric MICE synthetic data. The goal is to ensure that the synthetic data closely follows the real data’s numeric distribution.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Density plots for numeric variables (parametric imputed data)\ndensity_plots_param <- colnames(heart_failure)[map_lgl(heart_failure, is.numeric)] %>%\n  map(~ ggplot(combined_data_param, aes_string(.x, fill = 'dataset', group = 'dataset')) +\n        geom_density(alpha = 0.5) +\n        scale_fill_manual(values = c(\"real\" = \"#B0D99B\", \"synthetic\" = \"#528AA8\")) +\n        labs(x = .x, y = \"Density\")) %>%\n  patchwork::wrap_plots(ncol = 2) +  # Arrange plots in 2 columns\n  plot_annotation(title = \"Comparison of Numeric Variables Between real and Parametric Synthetic Data\",\n                  theme = theme(plot.title = element_text(hjust = 0.5)))\n\n# Print the combined density plots with one main title\nprint(density_plots_param)\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Density plots for numeric variables (parametric imputed data)-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n#### Non-Parametric Imputation (CART)\n\nCART is a non-parametric approach for generating synthetic data that captures complex relationships between variables without making distributional assumptions.\n\n##### Bar Plots for Categorical Variables\n\nThe bar plots compare the distribution of categorical variables in the real and synthetic datasets generated using the CART method.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Combine real and non-parametric CART synthetic datasets\nsyn_cart_1$dataset <- \"synthetic\"\n\n# Adjust the column names for synthetic data by removing the 'synth_' prefix\ncolnames(syn_cart_1) <- gsub(\"synth_\", \"\", colnames(syn_cart_1))\n\n# Combine both datasets (real and synthetic)\ncombined_data_cart <- bind_rows(heart_failure, syn_cart_1)\n\n# Bar plots for categorical variables (CART-imputed data)\nbar_plots_cart <- colnames(heart_failure)[map_lgl(heart_failure, is.factor)] %>%\n  map(~ ggplot(combined_data_cart, aes_string(.x, fill = 'dataset', group = 'dataset')) +\n        geom_bar(aes(y = ..prop..), position = position_dodge2(), stat = \"count\") +\n        scale_fill_manual(values = c(\"real\" = \"#B0D99B\", \"synthetic\" = \"#528AA8\")) +\n        labs(x = .x, y = \"Proportion\")) %>%\n  patchwork::wrap_plots() +\n  plot_annotation(title = \"Comparison of Categorical Variables Between real and Synthetic Data\",\n                  theme = theme(plot.title = element_text(hjust = 0.5)))\n\n# Print the combined plot with one main title\nprint(bar_plots_cart)\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Bar plots for categorical variables (CART-imputed data)-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n##### Density Plots for Numeric Variables\n\nThe density plots display how well the numeric variables in the CART-imputed synthetic data align with the real dataset.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Density plots for numeric variables (CART-imputed data)\ndensity_plots_cart <- colnames(heart_failure)[map_lgl(heart_failure, is.numeric)] %>%\n  map(~ ggplot(combined_data_cart, aes_string(.x, fill = 'dataset', group = 'dataset')) +\n        geom_density(alpha = 0.5) +\n        scale_fill_manual(values = c(\"real\" = \"#B0D99B\", \"synthetic\" = \"#528AA8\")) +\n        labs(x = .x, y = \"Density\")) %>%\n  patchwork::wrap_plots(ncol = 2) +  # Arrange plots in 2 columns\n  plot_annotation(title = \"Comparison of Numeric Variables Between real and Synthetic Data\",\n                  theme = theme(plot.title = element_text(hjust = 0.5)))\n\n# Print the combined density plots with one main title\nprint(density_plots_cart)\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Density plots for numeric variables (CART-imputed data)-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n#### Synthpop-Based Synthetic Data\n\nSynthpop is used to generate synthetic datasets that closely follow the distributions of the real data for privacy-preserving data sharing.\n\n##### Bar Plots for Categorical Variables\n\nThese bar plots assess how well Synthpop-based synthetic data maintains the categorical distributions of the real dataset.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Combine real and Synthpop-based synthetic datasets\nheart_failure$dataset <- \"real\"\nsyn_data_low_fidelity_synthpop$dataset <- \"synthetic\"\n\n# Adjust the column names for synthetic data by removing the 'synth_' prefix\ncolnames(syn_data_low_fidelity_synthpop) <- gsub(\"synth_\", \"\", colnames(syn_data_low_fidelity_synthpop))\n\n# Combine both datasets (real and synthetic)\ncombined_data_synthpop <- bind_rows(heart_failure, syn_data_low_fidelity_synthpop)\n\n# Bar plots for categorical variables (Synthpop-based synthetic data)\nbar_plots_synthpop <- colnames(heart_failure)[map_lgl(heart_failure, is.factor)] %>%\n  map(~ ggplot(combined_data_synthpop, aes_string(.x, fill = 'dataset', group = 'dataset')) +\n        geom_bar(aes(y = ..prop..), position = position_dodge2(), stat = \"count\") +\n        scale_fill_manual(values = c(\"real\" = \"#B0D99B\", \"synthetic\" = \"#528AA8\")) +\n        labs(x = .x, y = \"Proportion\")) %>%\n  patchwork::wrap_plots() +\n  plot_annotation(title = \"Comparison of Categorical Variables Between real and Synthetic Data\",\n                  theme = theme(plot.title = element_text(hjust = 0.5)))\n\n# Print the combined plot with one main title\nprint(bar_plots_synthpop)\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Bar plots for categorical variables (Synthpop-based synthetic data)-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n##### Density Plots for Numeric Variables\n\nThe density plots illustrate how closely Synthpop-based synthetic data matches the real dataset for numeric variables.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Combine real and Synthpop-based synthetic datasets\nheart_failure$dataset <- \"real\"\nsyn_data_low_fidelity_synthpop$dataset <- \"synthetic\"\ncombined_data_synthpop <- bind_rows(heart_failure, syn_data_low_fidelity_synthpop)\n\n# Density plots for numeric variables (Synthpop-based synthetic data)\ndensity_plots_synthpop <- colnames(heart_failure)[map_lgl(heart_failure, is.numeric)] %>%\n  map(~ ggplot(combined_data_synthpop, aes_string(.x, fill = 'dataset', group = 'dataset')) +\n        geom_density(alpha = 0.5) +\n        scale_fill_manual(values = c(\"real\" = \"#B0D99B\", \"synthetic\" = \"#528AA8\")) +\n        labs(x = .x, y = \"Density\")) %>%\n  patchwork::wrap_plots(ncol = 2) +  # Arrange plots in 2 columns\n  plot_annotation(title = \"Comparison of Numeric Variables Between real and Synthetic Data\",\n                  theme = theme(plot.title = element_text(hjust = 0.5)))\n\n# Print the combined density plots with one main title\nprint(density_plots_synthpop)\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Density plots for numeric variables (Synthpop-based synthetic data)-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n#### Metadata-Based Synthetic Data\n\nMetadata-based synthetic data generation uses a predefined data dictionary to ensure that the synthetic data follows the correct structure and distribution.\n\n##### Bar Plots for Categorical Variables\n\nWe compare the categorical variables of the real and metadata-based synthetic datasets to assess distributional alignment.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Combine real and Metadata-based synthetic datasets\nheart_failure$dataset <- \"real\"\nsyn_data_metadata$dataset <- \"synthetic\"\n\n# Adjust the column names for synthetic data by removing the 'synth_' prefix\ncolnames(syn_data_metadata) <- gsub(\"synth_\", \"\", colnames(syn_data_metadata))\n\n# Combine both datasets (real and synthetic)\ncombined_data_metadata <- bind_rows(heart_failure, syn_data_metadata)\n\n# Bar plots for categorical variables (Metadata-based synthetic data)\nbar_plots_metadata <- colnames(heart_failure)[map_lgl(heart_failure, is.factor)] %>%\n  map(~ ggplot(combined_data_metadata, aes_string(.x, fill = 'dataset', group = 'dataset')) +\n        geom_bar(aes(y = ..prop..), position = position_dodge2(), stat = \"count\") +\n        scale_fill_manual(values = c(\"real\" = \"#B0D99B\", \"synthetic\" = \"#528AA8\")) +\n        labs(x = .x, y = \"Proportion\")) %>%\n  patchwork::wrap_plots() +\n  plot_annotation(title = \"Comparison of Categorical Variables Between real and Synthetic Datasets\",\n                  theme = theme(plot.title = element_text(hjust = 0.5)))\n\n# Print the combined plot with one main title\nprint(bar_plots_metadata)\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Bar plots for categorical variables (Metadata-based synthetic data)-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n##### Density Plots for Numeric Variables\n\nThe density plots for numeric variables compare the distribution of numeric values between the real and metadata-based synthetic datasets.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Combine real and Metadata-based synthetic datasets\nheart_failure$dataset <- \"real\"\nsyn_data_metadata$dataset <- \"synthetic\"\ncombined_data_metadata <- bind_rows(heart_failure, syn_data_metadata)\n\n# Density plots for numeric variables (Metadata-based synthetic data)\ndensity_plots_metadata <- colnames(heart_failure)[map_lgl(heart_failure, is.numeric)] %>%\n  map(~ ggplot(combined_data_metadata, aes_string(.x, fill = 'dataset', group = 'dataset')) +\n        geom_density(alpha = 0.5) +\n        scale_fill_manual(values = c(\"real\" = \"#B0D99B\", \"synthetic\" = \"#528AA8\")) +\n        labs(x = .x, y = \"Density\")) %>%\n  patchwork::wrap_plots(ncol = 2) +  # Arrange plots in 2 columns\n  plot_annotation(title = \"Comparison of Numeric Variables Between real and Synthetic Data\",\n                  theme = theme(plot.title = element_text(hjust = 0.5)))\n\n# Print the combined density plots with one main title\nprint(density_plots_metadata)\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Density Plots for Numeric Variables-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n### Histogram Similarity Score\n\nThe Histogram Similarity Score measures how closely the marginal distributions of the synthetic data match the real data. Marginal distributions are critical for assessing whether key data characteristics such as spread, central tendency (mean/median), and shape (skewness/kurtosis) are preserved.\n\nIdeal Ranges for Histogram Similarity:\n\n- **Perfect Match:** 1 (100%) indicates a perfect match between the distributions.\n- **Good Match:** 0.85–1 (85% to 100%) shows strong similarity.\n- **Moderate Match:** 0.65–0.85 suggests some differences that may need addressing.\n- **Poor Match:** Below 0.65 indicates significant deviation from the real data.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Custom palette for datasets\ndataset_palette <- c(\n  \"Parametric MICE\"       = \"#B0D99B\",\n  \"CART Imputation\"       = \"#528AA8\",\n  \"Synthpop (Low Fidelity)\" = \"#FFB6DB\",\n  \"Metadata-Based\"        = \"#264653\"\n)\n\n# Define function once\ncalculate_histogram_similarity <- function(real_data, synthetic_data) {\n  real_numeric <- real_data[sapply(real_data, is.numeric)]\n  synthetic_numeric <- synthetic_data[sapply(synthetic_data, is.numeric)]\n  \n  similarity_scores <- sapply(names(real_numeric), function(var) {\n    real_hist <- hist(real_numeric[[var]], plot = FALSE)\n    synthetic_hist <- hist(synthetic_numeric[[var]], plot = FALSE)\n    \n    # Wasserstein distance between histogram midpoints\n    wasserstein_distance <- transport::wasserstein1d(real_hist$mids, synthetic_hist$mids)\n    1 / (1 + wasserstein_distance)  # similarity score\n  })\n  \n  mean(similarity_scores)\n}\n\n# Collect results in a tibble (convert to percentages)\nhist_sim_tbl <- tibble::tibble(\n  Dataset = c(\"Parametric MICE\", \"CART Imputation\", \"Synthpop (Low Fidelity)\", \"Metadata-Based\"),\n  Histogram_Similarity = c(\n    calculate_histogram_similarity(heart_failure, syn_data_1),\n    calculate_histogram_similarity(heart_failure, syn_cart_1),\n    calculate_histogram_similarity(heart_failure, syn_data_low_fidelity_synthpop),\n    calculate_histogram_similarity(heart_failure, syn_data_metadata)\n  )\n) %>%\n  mutate(Histogram_Similarity = round(Histogram_Similarity * 100, 1))  # percentage\n\n# Display as table\nkable(\n  hist_sim_tbl,\n  caption = \"Histogram Similarity Scores (%): higher = more similar to real data\",\n  align = \"lr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Histogram Similarity Scores (%): higher = more similar to real data\n\n|Dataset                 | Histogram_Similarity|\n|:-----------------------|--------------------:|\n|Parametric MICE         |                  9.5|\n|CART Imputation         |                  9.5|\n|Synthpop (Low Fidelity) |                  9.5|\n|Metadata-Based          |                  9.5|\n\n\n:::\n\n```{.r .cell-code}\n# Horizontal bar chart with custom colours\nggplot(hist_sim_tbl, aes(y = Dataset, x = Histogram_Similarity, fill = Dataset)) +\n  geom_col(alpha = 0.9, show.legend = FALSE) +\n  geom_text(aes(label = paste0(Histogram_Similarity, \"%\")), \n            hjust = -0.1, size = 3.3) +\n  scale_fill_manual(values = dataset_palette) +\n  scale_x_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 100)) +\n  labs(\n    title = \"Histogram Similarity by Synthetic Method\",\n    subtitle = \"Based on Wasserstein distance of variable histograms\",\n    x = \"Similarity (%)\", y = NULL\n  ) +\n  theme_minimal() +\n  theme(axis.text.y = element_text(size = 10))\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/histogram-similarity-score-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n### Mutual Information Score\n\nThe Mutual Information (MI) Score measures the shared information between pairs of features in the real and synthetic datasets, assessing how well relationships between variables are preserved.\n\nIdeal Ranges for Mutual Information:\n\n- **Perfect Alignment:** MI scores for synthetic data should ideally match the real within 10-20% for critical feature pairs.\n- **Lower MI:** Consistently lower MI scores suggest that noise has been added, weakening relationships.\n- **Overfitting Risk:** Higher MI scores than the real may indicate overfitting, increasing re-identification risk.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Custom palette for datasets\ndataset_palette <- c(\n  \"Parametric MICE\"         = \"#B0D99B\",\n  \"CART Imputation\"         = \"#528AA8\",\n  \"Synthpop (Low Fidelity)\" = \"#FFB6DB\",\n  \"Metadata-Based\"          = \"#264653\"\n)\n\n# ------- Helpers -------\n# Strip 'synth_' so variable names align with the real dataset\nstrip_synth_prefix <- function(df) {\n  names(df) <- sub(\"^synth_\", \"\", names(df))\n  df\n}\n\n# Compute pairwise MI matrix for a data.frame of discretized columns\ncompute_mi_matrix <- function(df_disc) {\n  p <- ncol(df_disc)\n  if (p < 2) return(matrix(numeric(0), nrow = p, ncol = p,\n                           dimnames = list(colnames(df_disc), colnames(df_disc))))\n  M <- matrix(0, nrow = p, ncol = p,\n              dimnames = list(colnames(df_disc), colnames(df_disc)))\n  for (i in seq_len(p)) {\n    for (j in i:p) {\n      # safe MI (skip NA rows; zero if not enough variation)\n      ok <- is.finite(df_disc[[i]]) & is.finite(df_disc[[j]])\n      xi <- df_disc[[i]][ok]; xj <- df_disc[[j]][ok]\n      mi <- if (length(unique(xi)) < 2 || length(unique(xj)) < 2) 0 else\n        suppressWarnings(infotheo::mutinformation(xi, xj))\n      M[i, j] <- mi\n      M[j, i] <- mi\n    }\n  }\n  M\n}\n\n# Compare two MI matrices (upper triangle only) -> 0–1 similarity score (higher = closer)\nmi_similarity_score <- function(M_real, M_synth) {\n  if (length(M_real) == 0 || length(M_synth) == 0) return(NA_real_)\n  common <- intersect(colnames(M_real), colnames(M_synth))\n  if (length(common) < 2) return(NA_real_)\n  R <- M_real[common, common, drop = FALSE]\n  S <- M_synth[common, common, drop = FALSE]\n  ut <- upper.tri(R, diag = FALSE)\n  mean_abs_diff <- mean(abs(R[ut] - S[ut]))\n  1 / (1 + mean_abs_diff)\n}\n\n# Discretize numeric columns (equal-frequency bins); keep only shared numeric vars\nMutual_Information <- function(real_df, synth_df, nbins = 10) {\n  real_num  <- dplyr::select(real_df,  where(is.numeric))\n  synth_num <- strip_synth_prefix(synth_df) |> dplyr::select(where(is.numeric))\n\n  common <- intersect(names(real_num), names(synth_num))\n  if (length(common) < 2) return(NA_real_)\n\n  real_num  <- real_num[common]\n  synth_num <- synth_num[common]\n\n  # Discretize numerics (returns integer codes)\n  real_disc  <- as.data.frame(lapply(real_num,  \\(x) infotheo::discretize(x, disc = \"equalfreq\", nbins = nbins)))\n  synth_disc <- as.data.frame(lapply(synth_num, \\(x) infotheo::discretize(x, disc = \"equalfreq\", nbins = nbins)))\n\n  # MI matrices and similarity score\n  M_real  <- compute_mi_matrix(real_disc)\n  M_synth <- compute_mi_matrix(synth_disc)\n  mi_similarity_score(M_real, M_synth)\n}\n\n# ------- Compute scores and present nicely (percentages) -------\nmi_results <- tibble::tibble(\n  Dataset = c(\"Parametric MICE\", \"CART Imputation\", \"Synthpop (Low Fidelity)\", \"Metadata-Based\"),\n  Mutual_Information = c(\n    Mutual_Information(heart_failure, syn_data_1),\n    Mutual_Information(heart_failure, syn_cart_1),\n    Mutual_Information(heart_failure, syn_data_low_fidelity_synthpop),\n    Mutual_Information(heart_failure, syn_data_metadata)\n  )\n) |>\n  mutate(Mutual_Information = round(Mutual_Information * 100, 1))  # convert to %\n\n# User-friendly table\nknitr::kable(\n  mi_results,\n  caption = \"Mutual Information Similarity (%): higher = synthetic preserves dependency structure more closely\",\n  align = \"lr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Mutual Information Similarity (%): higher = synthetic preserves dependency structure more closely\n\n|Dataset                 | Mutual_Information|\n|:-----------------------|------------------:|\n|Parametric MICE         |               93.3|\n|CART Imputation         |               94.3|\n|Synthpop (Low Fidelity) |               91.5|\n|Metadata-Based          |               93.2|\n\n\n:::\n\n```{.r .cell-code}\n# Horizontal bar chart with custom colours\nggplot(mi_results, aes(y = Dataset, x = Mutual_Information, fill = Dataset)) +\n  geom_col(alpha = 0.9, show.legend = FALSE) +\n  geom_text(aes(label = paste0(Mutual_Information, \"%\")), \n            hjust = -0.1, size = 3.3) +\n  scale_fill_manual(values = dataset_palette) +\n  scale_x_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 100)) +\n  labs(\n    title = \"Mutual Information Similarity by Synthetic Method\",\n    subtitle = \"Based on pairwise MI matrices of discretized numeric variables (equal-frequency bins)\",\n    x = \"Similarity (%)\", y = NULL\n  ) +\n  theme_minimal() +\n  theme(axis.text.y = element_text(size = 10))\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/mutual-information-score-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n### Correlation Score\n\nThe Correlation Score measures how well the relationships (correlations) between variables are preserved in the synthetic dataset compared to the real.\n\nIdeal Ranges for Correlation Score:\n\n- **Perfect Alignment:** Correlations in the synthetic data should match the real closely, with deviations of 5-10% being acceptable.\n- **Weaker Correlations:** If synthetic correlations are weaker, it may indicate loss of fidelity due to noise.\n- **Stronger Correlations:** Stronger correlations suggest overfitting, which may increase privacy risks.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Custom palette for datasets\ndataset_palette <- c(\n  \"Parametric MICE\"         = \"#B0D99B\",\n  \"CART Imputation\"         = \"#528AA8\",\n  \"Synthpop (Low Fidelity)\" = \"#FFB6DB\",\n  \"Metadata-Based\"          = \"#264653\"\n)\n\n# --- Helper: strip 'synth_' so names align\nstrip_synth_prefix <- function(df) {\n  names(df) <- sub(\"^synth_\", \"\", names(df))\n  df\n}\n\n# --- Function to calculate Correlation Similarity Score\ncalculate_correlation_score <- function(real_data, synthetic_data) {\n  # Keep numeric columns only\n  real_num  <- real_data[sapply(real_data, is.numeric)]\n  synth_num <- strip_synth_prefix(synthetic_data)[sapply(strip_synth_prefix(synthetic_data), is.numeric)]\n  \n  # Use only common variables\n  common <- intersect(names(real_num), names(synth_num))\n  if (length(common) < 2) return(NA_real_)\n  \n  real_corr  <- cor(real_num[common],  use = \"complete.obs\")\n  synth_corr <- cor(synth_num[common], use = \"complete.obs\")\n  \n  # Frobenius norm difference → similarity score in [0,1]\n  corr_diff <- norm(real_corr - synth_corr, type = \"F\")\n  1 / (1 + corr_diff)\n}\n\n# --- Compute scores for all synthetic datasets\ncorr_scores <- tibble::tibble(\n  Dataset = c(\"Parametric MICE\", \"CART Imputation\", \"Synthpop (Low Fidelity)\", \"Metadata-Based\"),\n  Correlation_Score = c(\n    calculate_correlation_score(heart_failure, syn_data_1),\n    calculate_correlation_score(heart_failure, syn_cart_1),\n    calculate_correlation_score(heart_failure, syn_data_low_fidelity_synthpop),\n    calculate_correlation_score(heart_failure, syn_data_metadata)\n  )\n) %>%\n  mutate(Correlation_Score = round(Correlation_Score * 100, 1))   # convert to %\n\n# --- User-friendly table\nkable(\n  corr_scores,\n  caption = \"Correlation Similarity Scores (%): higher = synthetic preserves correlation structure more closely\",\n  align = \"lr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Correlation Similarity Scores (%): higher = synthetic preserves correlation structure more closely\n\n|Dataset                 | Correlation_Score|\n|:-----------------------|-----------------:|\n|Parametric MICE         |              58.3|\n|CART Imputation         |              67.2|\n|Synthpop (Low Fidelity) |              53.4|\n|Metadata-Based          |              55.5|\n\n\n:::\n\n```{.r .cell-code}\n# --- Horizontal bar chart with custom colours\nggplot(corr_scores, aes(y = Dataset, x = Correlation_Score, fill = Dataset)) +\n  geom_col(alpha = 0.9, show.legend = FALSE) +\n  geom_text(aes(label = paste0(Correlation_Score, \"%\")), \n            hjust = -0.1, size = 3.3) +\n  scale_fill_manual(values = dataset_palette) +\n  scale_x_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 100)) +\n  labs(\n    title = \"Correlation Similarity by Synthetic Method\",\n    subtitle = \"Based on Frobenius norm difference between real and synthetic correlation matrices\",\n    x = \"Similarity (%)\", y = NULL\n  ) +\n  theme_minimal() +\n  theme(axis.text.y = element_text(size = 10))\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/correlation-score-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n## Utility Assessment\n\n### Feature Importance Consistency Assessment\n\nThe Feature Importance Consistency Assessment evaluates how well the synthetic datasets retain the predictive significance of features compared to the real dataset. This assessment is essential for ensuring that the synthetic data accurately reflects the underlying relationships that contribute to the model's predictive performance.\n\nFeature importance measures each variable's contribution to model predictions. Consistency in feature importance rankings between the real and synthetic datasets serves as a crucial indicator of data quality. Significant discrepancies may indicate deficiencies in the synthetic data generation process, potentially affecting the performance of models trained on synthetic data.\n\nIdeal Ranges for Feature Importance Consistency Assessment:\n\n- **Perfect Match**: Feature importance scores in the synthetic dataset should closely align with those in the real dataset, particularly for highly predictive features.\n- **Acceptable Deviation**: A deviation of 10-15% is generally acceptable for most features. For variables identified as highly influential, stricter thresholds may be needed to maintain predictive accuracy.\n\nTypes of Deviations\n\n- **Underrepresentation**: If an important feature has lower importance in the synthetic dataset, it may suggest that critical predictive relationships are not well-preserved.\n- **Overrepresentation**: If a feature's importance is higher in the synthetic data, this could indicate noise or overfitting, potentially distorting the model’s perception of feature relationships.\n\nThe following visualisation techniques will be used to compare feature importance:\n\n- **Bar Plots for Feature Importance Comparison**: Bar plots will compare feature importance scores between the real and synthetic datasets. This visual comparison can reveal significant deviations.\n- **SHAP Summary Plots**: SHAP (SHapley Additive exPlanations) summary plots provide a comprehensive view of the distribution of SHAP values for each feature, allowing for a direct comparison between the real and synthetic datasets.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Prepare the data for XGBoost\nset.seed(123)  # For reproducibility\ntrain_indices <- sample(seq_len(nrow(heart_failure)), size = 0.7 * nrow(heart_failure))\ntrain_real <- heart_failure[train_indices, ]\ntest_real <- heart_failure[-train_indices, ]\n\ntrain_real_matrix <- model.matrix(deceased ~ age + sex + anaemia + creatinine_phosphokinase + diabetes + ejection_fraction + platelets + serum_creatinine + serum_sodium + smoking + hypertension + follow_up - 1, data = train_real)\ntrain_real_label <- train_real[rownames(train_real_matrix), \"deceased\"]\ntrain_real_label <- as.numeric(train_real_label) - 1  # Convert factor to 0 and 1\n\ntrain_synth <- syn_data_1[train_indices, ]\ntrain_synth_matrix <- model.matrix(deceased ~ age + sex + anaemia + creatinine_phosphokinase + diabetes + ejection_fraction + platelets + serum_creatinine + serum_sodium + smoking + hypertension + follow_up - 1, data = train_synth)\ntrain_synth_label <- train_synth[rownames(train_synth_matrix), \"deceased\"]\ntrain_synth_label <- as.numeric(train_synth_label) - 1  # Convert factor to 0 and 1\n\n# Convert to DMatrix format, which is required for XGBoost\ndtrain_real <- xgb.DMatrix(data = train_real_matrix, label = train_real_label)\ndtrain_synth <- xgb.DMatrix(data = train_synth_matrix, label = train_synth_label)\n\n# Set up parameters for XGBoost\nparams <- list(\n  objective = \"binary:logistic\",\n  eval_metric = \"auc\",  # Use AUC as an evaluation metric\n  max_depth = 3,\n  eta = 0.1\n)\n\n# Tune hyperparameters using cross-validation (with parallel processing)\ncv_real <- xgb.cv(\n  params = params,\n  data = dtrain_real,\n  nrounds = 100,\n  nfold = 5,\n  verbose = 0,\n  early_stopping_rounds = 10,\n  nthread = num_cores  # Number of threads for parallel processing\n)\n\nbest_nrounds_real <- cv_real$best_iteration\n\ncv_synth <- xgb.cv(\n  params = params,\n  data = dtrain_synth,\n  nrounds = 100,\n  nfold = 5,\n  verbose = 0,\n  early_stopping_rounds = 10,\n  nthread = num_cores  # Number of threads for parallel processing\n)\n\nbest_nrounds_synth <- cv_synth$best_iteration\n\n# Train XGBoost on real data (TRTR)\nxgb_model_trtr <- xgboost(params = params, data = dtrain_real, nrounds = best_nrounds_real, verbose = 0, nthread = num_cores)\n\n# Train XGBoost on synthetic data (TSTR)\nxgb_model_tstr <- xgboost(params = params, data = dtrain_synth, nrounds = best_nrounds_synth, verbose = 0, nthread = num_cores)\n\n# Get feature importance for TRTR\nimportance_trtr <- xgb.importance(feature_names = colnames(train_real_matrix), model = xgb_model_trtr)\ncat(\"Feature Importance for TRTR:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFeature Importance for TRTR:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(importance_trtr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                    Feature        Gain      Cover  Frequency\n                     <char>       <num>      <num>      <num>\n1:                follow_up 0.550035467 0.35582680 0.26470588\n2:         serum_creatinine 0.179450673 0.25780255 0.22794118\n3:        ejection_fraction 0.107840968 0.17061583 0.12500000\n4: creatinine_phosphokinase 0.100830923 0.12847956 0.20588235\n5:             serum_sodium 0.032740748 0.04233723 0.08823529\n6:                      age 0.022510598 0.03446459 0.04411765\n7:                platelets 0.006590623 0.01047345 0.04411765\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get feature importance for TSTR\nimportance_tstr <- xgb.importance(feature_names = colnames(train_synth_matrix), model = xgb_model_tstr)\ncat(\"\\nFeature Importance for TSTR:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFeature Importance for TSTR:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(importance_tstr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                    Feature       Gain      Cover Frequency\n                     <char>      <num>      <num>     <num>\n1:                follow_up 0.37991328 0.37325270      0.20\n2:        ejection_fraction 0.22999025 0.21347069      0.32\n3:             serum_sodium 0.20146359 0.17350782      0.16\n4:                platelets 0.13419963 0.10862788      0.12\n5:         serum_creatinine 0.04007483 0.12057396      0.16\n6: creatinine_phosphokinase 0.01435841 0.01056696      0.04\n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualise feature importance for TRTR and TSTR\nimportance_trtr$Dataset <- \"Real Data\"\nimportance_tstr$Dataset <- \"Synthetic Data\"\n\nimportance_combined <- rbind(importance_trtr, importance_tstr)\n\n# Plot feature importance comparison\nggplot(importance_combined, aes(x = reorder(Feature, Gain), y = Gain, fill = Dataset)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  coord_flip() +\n  labs(title = \"Feature Importance Comparison (TRTR vs TSTR)\",\n       x = \"Feature\",\n       y = \"Gain\") +\n  scale_fill_manual(values = c(\"Real Data\" = \"#B0D99B\", \"Synthetic Data\" = \"#528AA8\")) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Feature Importance Consistency Assessment-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n```{.r .cell-code}\n# Correlation analysis between feature importance rankings\n\nimportance_trtr <- importance_trtr %>% mutate(rank = rank(-Gain))\nimportance_tstr <- importance_tstr %>% mutate(rank = rank(-Gain))\n\nimportance_ranking <- inner_join(importance_trtr, importance_tstr, by = \"Feature\", suffix = c(\"_trtr\", \"_tstr\"))\n\ncorrelation <- cor(importance_ranking$rank_trtr, importance_ranking$rank_tstr, method = \"spearman\")\ncat(\"\\nSpearman correlation Between TRTR and TSTR Feature Importance Rankings:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nSpearman correlation Between TRTR and TSTR Feature Importance Rankings:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(correlation)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3714286\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate SHAP values for better interpretability\n\n# SHAP values for TRTR\nshap_values_trtr <- shap.values(xgb_model_trtr, dtrain_real)\nshap_long_trtr <- shap.prep(shap_contrib = shap_values_trtr$shap_score, X_train = train_real_matrix)\n\ncat(\"\\nSHAP Summary for TRTR:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nSHAP Summary for TRTR:\n```\n\n\n:::\n\n```{.r .cell-code}\nshap_values_trtr$mean_shap_score %>% print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               follow_up         serum_creatinine        ejection_fraction \n              0.92293409               0.52780225               0.39932806 \ncreatinine_phosphokinase             serum_sodium                      age \n              0.18850937               0.10067811               0.06711965 \n               platelets                sexFemale                  sexMale \n              0.02991459               0.00000000               0.00000000 \n              anaemiaYes              diabetesYes               smokingYes \n              0.00000000               0.00000000               0.00000000 \n         hypertensionYes \n              0.00000000 \n```\n\n\n:::\n\n```{.r .cell-code}\n# SHAP values for TSTR\nshap_values_tstr <- shap.values(xgb_model_tstr, dtrain_synth)\nshap_long_tstr <- shap.prep(shap_contrib = shap_values_tstr$shap_score, X_train = train_synth_matrix)\n\ncat(\"\\nSHAP Summary for TSTR:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nSHAP Summary for TSTR:\n```\n\n\n:::\n\n```{.r .cell-code}\nshap_values_tstr$mean_shap_score %>% print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               follow_up        ejection_fraction                platelets \n             0.210816300              0.069274587              0.067060756 \n            serum_sodium         serum_creatinine creatinine_phosphokinase \n             0.058853411              0.035087248              0.006947092 \n                     age                sexFemale                  sexMale \n             0.000000000              0.000000000              0.000000000 \n              anaemiaYes              diabetesYes               smokingYes \n             0.000000000              0.000000000              0.000000000 \n         hypertensionYes \n             0.000000000 \n```\n\n\n:::\n\n```{.r .cell-code}\n# SHAP visualisation\nshap.plot.summary(shap_long_trtr)\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Feature Importance Consistency Assessment-2.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n\n```{.r .cell-code}\nshap.plot.summary(shap_long_tstr)\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Feature Importance Consistency Assessment-3.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n### Prediction Score\n\nThe Prediction Score assesses synthetic data utility by comparing models trained on real data (Train Real Test Real (TRTR)) versus synthetic data (Train Synthetic Test Real (TSTR)) using two metrics:\n\n- **Accuracy**: The proportion of correct predictions made by the model.\n- **pMSE (Prediction Mean Squared Error)**: Measures the average of the squared differences between predicted and actual values.\n\nIdeal Ranges for Prediction Score:\n\n- **Accuracy**: TSTR accuracy should be within 5-10% of TRTR accuracy. Lower accuracy signals that synthetic data isn’t fully representative of the real dataset.\n- **pMSE**: TSTR pMSE should be close to TRTR pMSE. A 5-10% deviation is acceptable; a higher pMSE suggests synthetic data may not be accurately reflecting the true relationships in the real data.\n\nThis section assesses the utility of synthetic data generated through various methods, using XGBoost to calculate both Accuracy and pMSE for TRTR and TSTR.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(123)\n\n# ---- helpers ----\nstrip_synth_prefix <- function(df) { names(df) <- sub(\"^synth_\", \"\", names(df)); df }\n\nalign_target_levels <- function(df, levels_ref = NULL, positive = NULL) {\n  if (!is.factor(df$deceased)) {\n    if (is.numeric(df$deceased)) df$deceased <- factor(as.character(df$deceased)) else df$deceased <- factor(df$deceased)\n  }\n  if (!is.null(levels_ref)) df$deceased <- factor(df$deceased, levels = levels_ref)\n  lev <- levels(df$deceased)\n  if (length(lev) < 2) stop(\"Target 'deceased' must have two levels.\")\n  pos <- if (!is.null(positive) && positive %in% lev) positive else if (\"1\" %in% lev) \"1\" else lev[2]\n  df$deceased <- stats::relevel(df$deceased, ref = pos)\n  list(data = df, levels = levels(df$deceased), positive = pos)\n}\n\nevaluate_model <- function(train_data, test_data, label, tune_grid, train_control, seed = 123) {\n  test_aln  <- align_target_levels(test_data)\n  train_aln <- align_target_levels(train_data, levels_ref = test_aln$levels, positive = test_aln$positive)\n  train_data <- train_aln$data\n  test_data  <- test_aln$data\n\n  set.seed(seed)\n  model <- caret::train(\n    deceased ~ follow_up + serum_creatinine + ejection_fraction +\n      creatinine_phosphokinase + serum_sodium + age + platelets,\n    data      = train_data,\n    method    = \"xgbTree\",\n    trControl = train_control,\n    tuneGrid  = tune_grid,\n    na.action = na.pass\n  )\n\n  pred <- predict(model, test_data)\n  acc  <- mean(pred == test_data$deceased, na.rm = TRUE)\n  yhat <- as.numeric(pred)\n  y    <- as.numeric(test_data$deceased)\n  pMSE <- mean((yhat - y)^2, na.rm = TRUE)\n\n  tibble::tibble(Dataset = label, Accuracy = acc, pMSE = pMSE)\n}\n\n# ---- CV setup ----\ntrain_control <- caret::trainControl(method = \"cv\", number = 5)\ntune_grid <- expand.grid(\n  nrounds = 50,\n  max_depth = 3,\n  eta = 0.1,\n  gamma = 0,\n  colsample_bytree = 0.8,\n  min_child_weight = 1,\n  subsample = 0.7\n)\n\n# ---- prepare synthetic splits ----\nsyn_mice      <- strip_synth_prefix(syn_data_1)\nsyn_cart      <- strip_synth_prefix(syn_cart_1)\nsyn_synthpop  <- strip_synth_prefix(syn_data_low_fidelity_synthpop)\nsyn_metadata  <- strip_synth_prefix(syn_data_metadata)\n\ntrain_synth_mice     <- syn_mice[train_indices, , drop = FALSE]\ntrain_synth_cart     <- syn_cart[train_indices, , drop = FALSE]\ntrain_synth_synthpop <- syn_synthpop[train_indices, , drop = FALSE]\ntrain_synth_metadata <- syn_metadata[train_indices, , drop = FALSE]\n\n# ---- results table ----\nresults <- dplyr::bind_rows(\n  evaluate_model(train_real,               test_real, \"TRTR (Real→Real)\",     tune_grid, train_control),\n  evaluate_model(train_synth_mice,         test_real, \"TSTR (MICE→Real)\",     tune_grid, train_control),\n  evaluate_model(train_synth_cart,         test_real, \"TSTR (CART→Real)\",     tune_grid, train_control),\n  evaluate_model(train_synth_synthpop,     test_real, \"TSTR (Synthpop→Real)\", tune_grid, train_control),\n  evaluate_model(train_synth_metadata,     test_real, \"TSTR (Metadata→Real)\", tune_grid, train_control)\n) %>%\n  mutate(\n    Accuracy = scales::percent(Accuracy, accuracy = 0.1),\n    pMSE     = round(pMSE, 3)\n  )\n\nknitr::kable(\n  results,\n  caption = \"Prediction Score Summary (XGBoost, 5-fold CV): TRTR vs TSTR\",\n  align = \"lrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Prediction Score Summary (XGBoost, 5-fold CV): TRTR vs TSTR\n\n|Dataset              | Accuracy|  pMSE|\n|:--------------------|--------:|-----:|\n|TRTR (Real→Real)     |    67.8%| 0.322|\n|TSTR (MICE→Real)     |    70.0%| 0.300|\n|TSTR (CART→Real)     |    70.0%| 0.300|\n|TSTR (Synthpop→Real) |    66.7%| 0.333|\n|TSTR (Metadata→Real) |    56.7%| 0.433|\n\n\n:::\n\n```{.r .cell-code}\n# ---- horizontal Accuracy bar chart ----\npalette5 <- c(\"#B0D99B\", \"#528AA8\", \"#FFB6DB\", \"#264653\", \"#2A9D8F\")\n\nplot_df <- results %>%\n  mutate(Accuracy_num = readr::parse_number(Accuracy) / 100)\n\nggplot(plot_df, aes(y = Dataset, x = Accuracy_num, fill = Dataset)) +\n  geom_col(alpha = 0.9, show.legend = FALSE) +\n  geom_text(aes(label = Accuracy), hjust = -0.1, size = 3.5) +\n  scale_fill_manual(values = setNames(palette5, unique(plot_df$Dataset))) +\n  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, 1)) +\n  labs(title = \"Model Accuracy: TRTR vs TSTR\", x = \"Accuracy\", y = NULL) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Prediction Score-1.pdf){fig-align='center' fig-pos='H' width=100%}\n:::\n:::\n\n\n\n\n\n### Quality Score (QScore)\n\nThe QScore provides a comprehensive evaluation of synthetic data by aggregating multiple metrics, such as distribution similarity, feature importance, and correlation preservation, into a single score. This offers a clear, overall assessment of how well the synthetic data replicates the real dataset.\n\nIdeal Ranges for QScore:\n\n- **Excellent Quality (0.8 - 1.0)**: Indicates the synthetic data closely mirrors the real and can be confidently used for most analyses.\n- **Good Quality (0.6 - 0.8)**: Reflects good alignment, with some minor deviations. Suitable for most use cases, but some caution is advised.\n- **Moderate Quality (0.4 - 0.6)**: The synthetic data may be useful for exploratory analysis but shows significant deviations in key metrics.\n- **Poor Quality (< 0.4)**: The synthetic data poorly aligns with the real and is likely unsuitable for most analytic or modeling tasks.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# ---- QScore helper ----\ncalculate_qscore <- function(real_data, synthetic_data, num_queries = 10) {\n  numeric_real_vars  <- names(real_data)[sapply(real_data, is.numeric)]\n  numeric_synth_vars <- names(synthetic_data)[sapply(synthetic_data, is.numeric)]\n  common_vars <- intersect(numeric_real_vars, numeric_synth_vars)\n  if (length(common_vars) == 0) return(NA_real_)\n\n  qscores <- replicate(num_queries, {\n    var_name <- sample(common_vars, 1)\n    fun_name <- sample(c(\"mean\", \"sum\"), 1)\n    fun      <- match.fun(fun_name)\n\n    real_val  <- fun(real_data[[var_name]],  na.rm = TRUE)\n    synth_val <- fun(synthetic_data[[var_name]], na.rm = TRUE)\n\n    if (!is.na(real_val) && real_val != 0 && !is.na(synth_val)) {\n      abs(real_val - synth_val) / abs(real_val)  # proportion difference (0–1)\n    } else {\n      0\n    }\n  })\n\n  mean(qscores, na.rm = TRUE)\n}\n\n# ---- Compute and present ----\nqscore_tbl <- tibble::tibble(\n  Dataset = c(\"Parametric MICE\", \"CART Imputation\",\n              \"Synthpop (Low Fidelity)\", \"Metadata-Based\"),\n  QScore = c(\n    calculate_qscore(heart_failure, syn_data_1),\n    calculate_qscore(heart_failure, syn_cart_1),\n    calculate_qscore(heart_failure, syn_data_low_fidelity_synthpop),\n    calculate_qscore(heart_failure, syn_data_metadata)\n  )\n) %>%\n  dplyr::mutate(\n    QScore_num = QScore,                                   # keep numeric 0–1\n    QScore_pct = scales::percent(QScore_num, accuracy = 0.1) # pretty %\n  )\n\n# --- User-friendly table (as percentages) ---\nknitr::kable(\n  qscore_tbl %>% dplyr::select(Dataset, `QScore (%)` = QScore_pct),\n  caption = \"Quality Score (QScore) — average % difference in aggregates (lower is better)\",\n  align = \"lr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Quality Score (QScore) — average % difference in aggregates (lower is better)\n\n|Dataset                 | QScore (%)|\n|:-----------------------|----------:|\n|Parametric MICE         |       8.8%|\n|CART Imputation         |       4.7%|\n|Synthpop (Low Fidelity) |      10.6%|\n|Metadata-Based          |       3.0%|\n\n\n:::\n\n```{.r .cell-code}\n# --- Horizontal bar chart (percent axis) ---\npal <- c(\"#B0D99B\", \"#528AA8\", \"#FFB6DB\", \"#264653\", \"#2A9D8F\")\n\nggplot(qscore_tbl, aes(y = Dataset, x = QScore_num, fill = Dataset)) +\n  geom_col(alpha = 0.9, show.legend = FALSE) +\n  geom_text(aes(label = QScore_pct), hjust = -0.1, size = 3.5) +\n  scale_fill_manual(values = setNames(pal[seq_len(nrow(qscore_tbl))], qscore_tbl$Dataset)) +\n  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, 1),\n                     expand = expansion(mult = c(0, 0.05))) +\n  labs(\n    title = \"QScore Comparison (Lower is Better)\",\n    subtitle = \"Average percentage difference between real and synthetic aggregates across random queries\",\n    x = \"QScore (%)\", y = NULL\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Quality Score-1.pdf){fig-align='center' fig-pos='H' width=99%}\n:::\n:::\n\n\n\n\n\n## Privacy / Disclosure Risk\n\n### Check for Replication of Real Value Combinations\n\nThis check identifies if any records in the synthetic data are exact duplicates of those in the real dataset. High replication increases privacy risks, so minimal or no duplication is ideal for preserving privacy.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# ---- Helper: replicated rows count ----\ncheck_replicated_rows <- function(real_data, synthetic_data) {\n  combined <- rbind(real_data, synthetic_data)\n  sum(duplicated(combined))\n}\n\n# ---- Build results table ----\nreplication_tbl <- tibble::tibble(\n  Dataset = c(\"Parametric MICE\", \"Non-Parametric CART\", \n              \"Synthpop (Low Fidelity)\", \"Metadata-Based\"),\n  Replicated_Rows = c(\n    check_replicated_rows(heart_failure, syn_data_1),\n    check_replicated_rows(heart_failure, syn_cart_1),\n    check_replicated_rows(heart_failure, syn_data_low_fidelity_synthpop),\n    check_replicated_rows(heart_failure, syn_data_metadata)\n  )\n) %>%\n  mutate(\n    Total_Rows = nrow(heart_failure),\n    Replication_Percent = round((Replicated_Rows / Total_Rows) * 100, 2),\n    Status = ifelse(Replicated_Rows > 0, \"⚠️ Replication Found\", \"✅ No Replication\")\n  )\n\n# ---- User-friendly table ----\nknitr::kable(\n  replication_tbl,\n  caption = \"Replication Check: Exact Matching Rows Between Real and Synthetic Datasets\",\n  align = \"lrrrl\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Replication Check: Exact Matching Rows Between Real and Synthetic Datasets\n\n|Dataset                 | Replicated_Rows| Total_Rows| Replication_Percent|Status            |\n|:-----------------------|---------------:|----------:|-------------------:|:-----------------|\n|Parametric MICE         |               0|        299|                   0|✅ No Replication |\n|Non-Parametric CART     |               0|        299|                   0|✅ No Replication |\n|Synthpop (Low Fidelity) |               0|        299|                   0|✅ No Replication |\n|Metadata-Based          |               0|        299|                   0|✅ No Replication |\n\n\n:::\n\n```{.r .cell-code}\n# ---- Optional: bar chart if any replication > 0 ----\nif (any(replication_tbl$Replicated_Rows > 0)) {\n  pal <- c(\"#B0D99B\", \"#528AA8\", \"#FFB6DB\", \"#264653\")\n  \n  ggplot(replication_tbl, aes(y = Dataset, x = Replicated_Rows, fill = Dataset)) +\n    geom_col(alpha = 0.9, show.legend = FALSE) +\n    geom_text(aes(label = Replicated_Rows), hjust = -0.1, size = 3.5) +\n    scale_fill_manual(values = pal[seq_len(nrow(replication_tbl))]) +\n    labs(\n      title = \"Replication of Real Rows in Synthetic Data\",\n      subtitle = \"Counts of exact duplicated rows across real and synthetic datasets\",\n      x = \"Number of Replicated Rows\", y = NULL\n    ) +\n    theme_minimal()\n} else {\n  cat(\"✅ No replicated rows were found across any synthetic dataset. No plot is generated.\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ No replicated rows were found across any synthetic dataset. No plot is generated.\n```\n\n\n:::\n:::\n\n\n\n\n\n### Check for Unique Value Combinations\n\nThis analysis compares the number of unique row combinations between the real and synthetic datasets. A high number of unique combinations in the synthetic data suggests that it captures diverse patterns while minimising the replication of sensitive information, enhancing privacy protection.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# ---- Helper: count unique rows ----\nunique_combinations <- function(data) {\n  nrow(unique(data))\n}\n\n# ---- Build results table ----\nunique_tbl <- tibble::tibble(\n  Dataset = c(\"Real Data\", \"Parametric MICE\", \n              \"Non-Parametric CART\", \"Synthpop (Low Fidelity)\", \n              \"Metadata-Based\"),\n  Unique_Combinations = c(\n    unique_combinations(heart_failure),\n    unique_combinations(syn_data_1),\n    unique_combinations(syn_cart_1),\n    unique_combinations(syn_data_low_fidelity_synthpop),\n    unique_combinations(syn_data_metadata)\n  )\n) %>%\n  mutate(\n    Total_Rows = c(nrow(heart_failure), rep(nrow(heart_failure), 4)),\n    Percent_Unique = round((Unique_Combinations / Total_Rows) * 100, 2)\n  )\n\n# ---- User-friendly table ----\nknitr::kable(\n  unique_tbl,\n  caption = \"Unique Value Combinations in Real vs. Synthetic Datasets\",\n  align = \"lrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Unique Value Combinations in Real vs. Synthetic Datasets\n\n|Dataset                 | Unique_Combinations| Total_Rows|Percent_Unique |\n|:-----------------------|-------------------:|----------:|:--------------|\n|Real Data               |                 299|        299|100            |\n|Parametric MICE         |                 299|        299|100            |\n|Non-Parametric CART     |                 299|        299|100            |\n|Synthpop (Low Fidelity) |                 299|        299|100            |\n|Metadata-Based          |                 299|        299|100            |\n\n\n:::\n\n```{.r .cell-code}\n# ---- Plot only if any dataset has > 0 unique rows ----\nif (any(unique_tbl$Unique_Combinations > 0, na.rm = TRUE)) {\n  pal <- c(\"#B0D99B\", \"#528AA8\", \"#FFB6DB\", \"#264653\", \"#2A9D8F\")\n\n  ggplot(unique_tbl, aes(y = Dataset, x = Percent_Unique, fill = Dataset)) +\n    geom_col(alpha = 0.9, show.legend = FALSE) +\n    geom_text(aes(label = paste0(Percent_Unique, \"%\")), hjust = -0.1, size = 3.5) +\n    scale_fill_manual(values = pal[seq_len(nrow(unique_tbl))]) +\n    scale_x_continuous(limits = c(0, 100)) +\n    labs(\n      title = \"Percentage of Unique Row Combinations\",\n      subtitle = \"Higher % means fewer duplicates within the dataset\",\n      x = \"Percent of Rows that are Unique\", y = NULL\n    ) +\n    theme_minimal()\n} else {\n  cat(\"✅ No unique combinations detected across datasets.  No plot is generated. \\n\")\n}\n```\n\n::: {.cell-output-display}\n![](heart_failure_synthetic_data_project_files/figure-pdf/Check for Unique Value Combinations-1.pdf){fig-align='center' fig-pos='H' width=99%}\n:::\n:::\n\n\n\n\n\n### Exact Match Score\n\nThe Exact Match Score measures how many individual records in the synthetic data are identical to records in the real dataset. Lower scores are ideal for privacy preservation, as high exact matches may pose privacy risks.\n\nIdeal Ranges for Exact Match Score:\n\n- **0 - 0.1**: Strong privacy protection with minimal or no exact matches, ideal for most privacy-preserving synthetic data.\n- **0.1 - 0.3**: Moderate exact matches, indicating some privacy risk but generally acceptable for many use cases.\n- **0.3 - 0.5**: Higher exact matches, raising privacy concerns. Review is needed to ensure proper data generation.\n- **Above 0.5**: Significant privacy risk, as the synthetic data too closely replicates the real.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# ---- Helper: Membership Inference Score ----\ncalculate_membership_inference_score <- function(real_data, synthetic_data, k = 5, threshold = 0.01) {\n  real_num  <- real_data[sapply(real_data, is.numeric)]\n  synth_num <- synthetic_data[sapply(synthetic_data, is.numeric)]\n  if (ncol(real_num) == 0 || ncol(synth_num) == 0) return(NA_real_)\n  common <- intersect(names(real_num), names(synth_num))\n  if (length(common) == 0) return(NA_real_)\n  real_num  <- real_num[common]\n  synth_num <- synth_num[common]\n  real_cc  <- real_num[complete.cases(real_num), , drop = FALSE]\n  synth_cc <- synth_num[complete.cases(synth_num), , drop = FALSE]\n  if (nrow(real_cc) < k || nrow(synth_cc) == 0) return(NA_real_)\n  real_scaled  <- scale(real_cc)\n  synth_scaled <- scale(synth_cc)\n  nn <- FNN::get.knnx(real_scaled, synth_scaled, k)$nn.dist\n  risky <- sum(rowMeans(nn) < threshold)\n  risky / nrow(synth_scaled)\n}\n\n# ---- Results table ----\nmis_tbl <- tibble::tibble(\n  Dataset = c(\"Parametric MICE\", \"Non-Parametric CART\",\n              \"Synthpop (Low Fidelity)\", \"Metadata-Based\"),\n  Membership_Inference_Score = c(\n    calculate_membership_inference_score(heart_failure, syn_data_1),\n    calculate_membership_inference_score(heart_failure, syn_cart_1),\n    calculate_membership_inference_score(heart_failure, syn_data_low_fidelity_synthpop),\n    calculate_membership_inference_score(heart_failure, syn_data_metadata)\n  )\n) %>%\n  mutate(\n    Membership_Inference_Score = round(Membership_Inference_Score, 4),\n    Status = dplyr::case_when(\n      is.na(Membership_Inference_Score)              ~ \"— Insufficient data\",\n      Membership_Inference_Score == 0                ~ \"✅ No risky memberships\",\n      Membership_Inference_Score < 0.01              ~ \"⚠️ Low risk\",\n      TRUE                                           ~ \"❌ High risk\"\n    )\n  )\n\n# ---- User-friendly table ----\nknitr::kable(\n  mis_tbl,\n  caption = \"Membership Inference Score: Proportion of synthetic records that are very close to real records (lower is better for privacy)\",\n  align   = \"lrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Membership Inference Score: Proportion of synthetic records that are very close to real records (lower is better for privacy)\n\n|Dataset                 | Membership_Inference_Score|                  Status|\n|:-----------------------|--------------------------:|-----------------------:|\n|Parametric MICE         |                          0| ✅ No risky memberships|\n|Non-Parametric CART     |                          0| ✅ No risky memberships|\n|Synthpop (Low Fidelity) |                          0| ✅ No risky memberships|\n|Metadata-Based          |                          0| ✅ No risky memberships|\n\n\n:::\n\n```{.r .cell-code}\n# ---- Conditional plot ----\nif (any(mis_tbl$Membership_Inference_Score > 0, na.rm = TRUE)) {\n  pal <- c(\"#B0D99B\", \"#528AA8\", \"#FFB6DB\", \"#264653\")\n  ggplot(mis_tbl, aes(y = Dataset, x = Membership_Inference_Score, fill = Dataset)) +\n    geom_col(alpha = 0.9, show.legend = FALSE, na.rm = TRUE) +\n    geom_text(\n      aes(label = ifelse(is.na(Membership_Inference_Score), \"NA\",\n                         scales::percent(Membership_Inference_Score, accuracy = 0.01))),\n      hjust = -0.1, size = 3.5\n    ) +\n    scale_fill_manual(values = pal[seq_len(nrow(mis_tbl))]) +\n    scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +\n    labs(\n      title    = \"Membership Inference Score by Synthetic Method\",\n      subtitle = \"Lower values indicate better privacy protection\",\n      x = \"Score (Proportion of risky memberships)\",\n      y = NULL\n    ) +\n    theme_minimal()\n} else {\n  cat(\"✅ All Membership Inference Scores are 0. No privacy risks detected, so no plot is generated\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ All Membership Inference Scores are 0. No privacy risks detected, so no plot is generated\n```\n\n\n:::\n:::\n\n\n\n\n\n### Neighbors' Privacy Score\n\nThe Neighbors' Privacy Score identifies real records that are \"too similar\" to synthetic records by using a nearest-neighbors search. This metric helps evaluate privacy risk by detecting synthetic records that closely resemble real data, which could compromise privacy.\n\nIdeal Ranges for Neighbors' Privacy Score:\n\n- **0 - 0.1**: Indicates strong privacy protection, with very few synthetic records too similar to real ones.\n- **0.1 - 0.3**: Moderate similarity, where privacy risk exists but remains within acceptable limits for many cases.\n- **Above 0.3**: Higher similarity, raising privacy concerns and requiring review to ensure the synthetic data is not too closely mimicking real data.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# ---- Helper: Neighbors' Privacy Score ----\ncalculate_neighbors_privacy_score <- function(real_data, synthetic_data, k = 5, threshold = 0.01) {\n  # Numeric-only columns\n  real_num  <- real_data[sapply(real_data, is.numeric)]\n  synth_num <- synthetic_data[sapply(synthetic_data, is.numeric)]\n  \n  if (ncol(real_num) == 0 || ncol(synth_num) == 0) return(NA_real_)\n  \n  # Keep only common columns\n  common <- intersect(names(real_num), names(synth_num))\n  if (length(common) == 0) return(NA_real_)\n  real_num  <- real_num[common]\n  synth_num <- synth_num[common]\n  \n  # Complete cases\n  real_cc  <- real_num[complete.cases(real_num), , drop = FALSE]\n  synth_cc <- synth_num[complete.cases(synth_num), , drop = FALSE]\n  \n  if (nrow(real_cc) < k || nrow(synth_cc) == 0) return(NA_real_)\n  \n  # Standardise\n  real_scaled  <- scale(real_cc)\n  synth_scaled <- scale(synth_cc)\n  \n  # k-NN distances from synthetic → real\n  neighbors <- FNN::get.knnx(real_scaled, synth_scaled, k)$nn.dist\n  \n  # Privacy risk: synthetic records \"too close\" to real\n  close_matches <- sum(rowMeans(neighbors) < threshold)\n  score <- close_matches / nrow(synth_scaled)\n  \n  return(score)\n}\n\n# ---- Build results table ----\nneighbors_tbl <- tibble::tibble(\n  Dataset = c(\"Parametric MICE\", \"Non-Parametric CART\",\n              \"Synthpop (Low Fidelity)\", \"Metadata-Based\"),\n  Neighbors_Privacy_Score = c(\n    calculate_neighbors_privacy_score(heart_failure, syn_data_1),\n    calculate_neighbors_privacy_score(heart_failure, syn_cart_1),\n    calculate_neighbors_privacy_score(heart_failure, syn_data_low_fidelity_synthpop),\n    calculate_neighbors_privacy_score(heart_failure, syn_data_metadata)\n  )\n) %>%\n  mutate(\n    Neighbors_Privacy_Score = round(Neighbors_Privacy_Score, 4),\n    Status = case_when(\n      Neighbors_Privacy_Score == 0 ~ \"✅ No risky neighbors\",\n      Neighbors_Privacy_Score < 0.01 ~ \"⚠️ Low risk\",\n      TRUE ~ \"❌ High risk\"\n    )\n  )\n\n# ---- User-friendly table ----\nknitr::kable(\n  neighbors_tbl,\n  caption = \"Neighbors' Privacy Score: Proportion of synthetic records too close to real records (lower is better for privacy)\",\n  align = \"lrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Neighbors' Privacy Score: Proportion of synthetic records too close to real records (lower is better for privacy)\n\n|Dataset                 | Neighbors_Privacy_Score|                Status|\n|:-----------------------|-----------------------:|---------------------:|\n|Parametric MICE         |                       0| ✅ No risky neighbors|\n|Non-Parametric CART     |                       0| ✅ No risky neighbors|\n|Synthpop (Low Fidelity) |                       0| ✅ No risky neighbors|\n|Metadata-Based          |                       0| ✅ No risky neighbors|\n\n\n:::\n\n```{.r .cell-code}\n# ---- Plot only if any score > 0 ----\nif (any(neighbors_tbl$Neighbors_Privacy_Score > 0)) {\n  pal <- c(\"#B0D99B\", \"#528AA8\", \"#FFB6DB\", \"#264653\")\n  \n  ggplot(neighbors_tbl, aes(y = Dataset, x = Neighbors_Privacy_Score, fill = Dataset)) +\n    geom_col(alpha = 0.9, show.legend = FALSE) +\n    geom_text(aes(label = Neighbors_Privacy_Score), hjust = -0.1, size = 3.5) +\n    scale_fill_manual(values = pal[seq_len(nrow(neighbors_tbl))]) +\n    scale_x_continuous(labels = scales::percent_format(accuracy = 0.1)) +\n    labs(\n      title = \"Neighbors' Privacy Score by Synthetic Method\",\n      subtitle = \"Lower values mean synthetic records are less likely to be close replicas of real individuals\",\n      x = \"Privacy Score (Proportion of risky neighbors)\", y = NULL\n    ) +\n    theme_minimal()\n} else {\n  cat(\"✅ All Neighbors' Privacy Scores are 0. No risky neighbors detected. No plot is generated.\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ All Neighbors' Privacy Scores are 0. No risky neighbors detected. No plot is generated.\n```\n\n\n:::\n:::\n\n\n\n\n\n### Membership Inference Score\n\nThe Membership Inference Score evaluates the risk of membership inference attacks, which attempt to determine whether a specific record belongs to the real dataset. This metric helps assess the vulnerability of synthetic data to privacy breaches.\n\nIdeal Ranges for Membership Inference Score:\n\n- **0 - 0.1**: Indicates low risk, where it is unlikely that membership inference attacks can accurately identify real records.\n- **0.1 - 0.3**: Moderate risk, where some vulnerability to membership inference exists but may still be acceptable for certain use cases.\n- **Above 0.3**: High risk, suggesting significant privacy concerns as the synthetic data could reveal membership information about the real records.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# ---- Helper: Membership Inference Score ----\n# Interpreted as the proportion of synthetic records that are \"too close\" to the real data.\n# Lower is better (safer).\ncalculate_membership_inference_score <- function(real_data, synthetic_data, k = 5, threshold = 0.01) {\n  # Numeric-only columns\n  real_num  <- real_data[sapply(real_data, is.numeric)]\n  synth_num <- synthetic_data[sapply(synthetic_data, is.numeric)]\n\n  # Guardrails\n  if (ncol(real_num) == 0 || ncol(synth_num) == 0) return(NA_real_)\n\n  # Keep only common numeric variables\n  common <- intersect(names(real_num), names(synth_num))\n  if (length(common) == 0) return(NA_real_)\n  real_num  <- real_num[common]\n  synth_num <- synth_num[common]\n\n  # Use complete cases\n  real_cc  <- real_num[complete.cases(real_num), , drop = FALSE]\n  synth_cc <- synth_num[complete.cases(synth_num), , drop = FALSE]\n  if (nrow(real_cc) < k || nrow(synth_cc) == 0) return(NA_real_)\n\n  # Standardize\n  real_scaled  <- scale(real_cc)\n  synth_scaled <- scale(synth_cc)\n\n  # k-NN distances from synthetic → real\n  nn <- FNN::get.knnx(real_scaled, synth_scaled, k)$nn.dist\n\n  # Score: proportion of synthetic records whose average distance to k nearest reals is below threshold\n  risky <- sum(rowMeans(nn) < threshold)\n  risky / nrow(synth_scaled)\n}\n\n# ---- Results table ----\nmis_tbl <- tibble::tibble(\n  Dataset = c(\"Parametric MICE\", \"Non-Parametric CART\",\n              \"Synthpop (Low Fidelity)\", \"Metadata-Based\"),\n  Membership_Inference_Score = c(\n    calculate_membership_inference_score(heart_failure, syn_data_1),\n    calculate_membership_inference_score(heart_failure, syn_cart_1),\n    calculate_membership_inference_score(heart_failure, syn_data_low_fidelity_synthpop),\n    calculate_membership_inference_score(heart_failure, syn_data_metadata)\n  )\n) %>%\n  mutate(\n    Membership_Inference_Score = round(Membership_Inference_Score, 4),\n    Status = dplyr::case_when(\n      is.na(Membership_Inference_Score)              ~ \"— Insufficient data\",\n      Membership_Inference_Score == 0                ~ \"✅ No risky memberships\",\n      Membership_Inference_Score < 0.01              ~ \"⚠️ Low risk\",\n      TRUE                                           ~ \"❌ High risk\"\n    )\n  )\n\n# ---- User-friendly table ----\nknitr::kable(\n  mis_tbl,\n  caption = \"Membership Inference Score: Proportion of synthetic records that are very close to real records (lower is better for privacy)\",\n  align   = \"lrr\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Membership Inference Score: Proportion of synthetic records that are very close to real records (lower is better for privacy)\n\n|Dataset                 | Membership_Inference_Score|                  Status|\n|:-----------------------|--------------------------:|-----------------------:|\n|Parametric MICE         |                          0| ✅ No risky memberships|\n|Non-Parametric CART     |                          0| ✅ No risky memberships|\n|Synthpop (Low Fidelity) |                          0| ✅ No risky memberships|\n|Metadata-Based          |                          0| ✅ No risky memberships|\n\n\n:::\n\n```{.r .cell-code}\n# ---- Plot only if any risky memberships (> 0) ----\nif (any(mis_tbl$Membership_Inference_Score > 0, na.rm = TRUE)) {\n  pal <- c(\"#B0D99B\", \"#528AA8\", \"#FFB6DB\", \"#264653\")\n  \n  ggplot(mis_tbl, aes(y = Dataset, x = Membership_Inference_Score, fill = Dataset)) +\n    geom_col(alpha = 0.9, show.legend = FALSE, na.rm = TRUE) +\n    geom_text(\n      aes(label = ifelse(is.na(Membership_Inference_Score), \"NA\",\n                         scales::percent(Membership_Inference_Score, accuracy = 0.01))),\n      hjust = -0.1, size = 3.5\n    ) +\n    scale_fill_manual(values = pal[seq_len(nrow(mis_tbl))]) +\n    scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +\n    labs(\n      title    = \"Membership Inference Score by Synthetic Method\",\n      subtitle = \"Lower values indicate better privacy protection\",\n      x = \"Score (Proportion of risky memberships)\",\n      y = NULL\n    ) +\n    theme_minimal()\n} else {\n  cat(\"✅ All Membership Inference Scores are 0. No risky memberships detected. No plot is generated. \\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n✅ All Membership Inference Scores are 0. No risky memberships detected. No plot is generated. \n```\n\n\n:::\n:::\n\n\n\n\n\n## Conclusions\n\nThis report evaluated the fidelity, utility, privacy, and overall quality of synthetic data generated using parametric MICE, non-parametric CART, Synthpop, and metadata-based methods. Key findings include:\n\n- **Data Structure Preservation**: All methods preserved the structure of the real dataset, though minor variations in variable distributions were observed.\n- **Categorical Variables**: Most synthetic datasets retained categorical levels, but frequency distribution discrepancies were particularly notable in Synthpop data.\n- **Numeric Variables**: The range and distribution of numeric variables were largely maintained across methods, with slight variations in density plots.\n- **Correlation & Mutual Information**: While most methods captured variable relationships, weaker correlations and lower mutual information scores suggested some loss of feature dependencies in certain synthetic datasets.\n- **Utility (Prediction Score)**: Synthetic data performed similarly to real data in predictive modeling, though slight reductions in accuracy and increased pMSE indicated less precise representation of the real dataset's predictive capabilities.\n- **Privacy (Exact Match & Neighbors' Privacy Scores)**: All synthetic datasets demonstrated strong privacy protection, with zero values for both Exact Match and Neighbors' Privacy Scores. This indicates that no synthetic records were identical to or highly similar to any real records, affirming robust privacy across all methods.\n\nIn conclusion, synthetic data generated through these methods provides a balance between utility and privacy, though method selection should align with specific analytic or privacy needs.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Stop the parallel cluster\nstopCluster(cl)\nregisterDoSEQ()\n```\n:::\n",
    "supporting": [
      "heart_failure_synthetic_data_project_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}